{"CRAWLED FILES":{"DIRECTORY":"D:\\Work\\dataextractor\\work\\pdf","FILES":[{"CONTENT":"\nAngularJS Directives\nLearn how to craft dynamic directives to fuel your \nsingle-page web applications using AngularJS\nAlex Vanston\n   BIRMINGHAM - MUMBAI\nAngularJS Directives\nCopyright © 2013 Packt Publishing\nAll rights reserved. No part of this book may be reproduced, stored in a retrieval \nsystem, or transmitted in any form or by any means, without the prior written \npermission of the publisher, except in the case of brief quotations embedded in \ncritical articles or reviews.\nEvery effort has been made in the preparation of this book to ensure the accuracy \nof the information presented. However, the information contained in this book is \nsold without warranty, either express or implied. Neither the author, nor Packt \nPublishing, and its dealers and distributors will be held liable for any damages \ncaused or alleged to be caused directly or indirectly by this book.\nPackt Publishing has endeavored to provide trademark information about all of the \ncompanies and products mentioned in this book by the appropriate use of capitals. \nHowever, Packt Publishing cannot guarantee the accuracy of this information.\nFirst published: August 2013\nProduction Reference: 1200813\nPublished by Packt Publishing Ltd.\nLivery Place 35 Livery Street Birmingham B3 2PB, UK.\nISBN 978-1-78328-033-9\nwww.packtpub.com Cover Image by Eleanor Leonne Bennett (\neleanor.ellieonline@gmail.com )\nCredits\nAuthorAlex Vanston Reviewers Jeff Cunningham Brian Petro Acquisition Editor Rukhsana Khambatta Commissioning Editor Subho Gupta Technical Editors Manan Badani Monica John Sampreshita Maheshwari\nProject Coordinator Michelle Quadros Proofreader Stephen Silk Indexer Tejal R. Soni Graphics Abhinash Sahu Production Coordinator \nConidon Miranda Cover Work Conidon Miranda\nAbout the Author\nAlex Vanston  is a self-professed geek and an outdoor junkie fused together. \nDuring high-school he began teaching himself how to code and has been obsessed \nwith learning new languages and better ways to solve problems ever since. He has \nbeen building web sites and applications professionally for the past seven years, for \nclients and companies around the world. Currently he lives in Denver, CO, where he \nloves hiking (5 14ers down, 49 to go), playing pickup sports, and water skiing when \nhe can. He's the lead front-end developer for ZipKick, Inc, a travel startup taking off \nin San Francisco, CA. You can find him online at \nhttp:\/\/www.mrvdot.com , where  \nhe blogs about web development and tech.\nA huge thank you to the innumerable friends and family who have \nencouraged me through this writing process, listened to me wrestle \nwith word choice and politely ignored me when I inexplicably begin \nmonologuing at random moments when a new idea hit me.\nAbout the Reviewers\nJeff Cunningham  is a mobile developer for The General Insurance. After 15 years \nof Java web development, he is now enjoying the challenges of front-end and mobile \nweb development. Prior to working for The General, Jeff worked at The Weather \nChannel where he was able to use both of his college degrees: Atmospheric Science \nand Computer Science. When not programming, Jeff enjoys reading, spending time \nwith his family, and watching sports.\nBrian Petro  has long been a proponent of AngularJS. He has curated a handful of \ndeveloper resources dedicated to Angular. For example, 'Angular Developers' is a \ngroup on LinkedIn where users can access the latest community generated material. \nThrough these experiences, Brian observed a significant deficit of talent in this fast \ngrowing field. AngularJobs.com is a place where developers find opportunities to \nwork with Angular. I would like to thank the author for providing a much needed \nresource on this topic.\nwww.PacktPub.com\nSupport files, eBooks, discount offers \nand more You might want to visit www.PacktPub.com  for support files and downloads related to \n \nyour book. Did you know that Packt offers eBook versions of every book published, with PDF and ePub \nfiles available? You can upgrade to the eBook version at \nwww.PacktPub.com  and as a print \nbook customer, you are entitled to a discount on the eBook copy. Get in touch with us at \nservice@packtpub.com  for more details.\nAt www.PacktPub.com , you can also read a collection of free technical articles, sign up for a \nrange of free newsletters and receive exclusive discounts and offers on Packt books and eBooks.\nhttp:\/\/PacktLib.PacktPub.com  Do you need instant solutions to your IT questions? PacktLib is Packt's online digital book \nlibrary. Here, you can access, read and search across Packt's entire library of books. \nWhy Subscribe?\n• Fully searchable across every book published by Packt\n• Copy and paste, print and bookmark content\n• On demand and accessible via web browser\nFree Access for Packt account holders\nIf you have an account with Packt at www.PacktPub.com , you can use this to access PacktLib \ntoday and view nine entirely free books. Simply use your login credentials for immediate access.\nTable of Contents\nPreface \n1\nChapter 1: Designing Web Applications in 2013 5\nAn overview of good code 5\nWe're not just talking about a lot of APIs 6\nModularity \n7\nData driven development 8\nLoading the data 9\nStructuring our HTML  \n9\nAdding JavaScript 10\nSummary \n10\nChapter 2: The Need for Directives 11\nWhat makes a directive a directive 11\nDirectives are declarative 11\nDirectives are data driven 13\nDirectives are conversational 14\nDirectives are everything you've dreamed about 15\nSummary \n15\nChapter 3: Deconstructing Directives 17\nGetting started 17\nWith Angular \n17\nWith directives 19\nNaming \n20\nAttachment styles 21\nConfiguration options 22\nPriority \n22\nTerminal \n23\nTemplating \n23\nReplace \n23\nTable of Contents\n[ ii ]\nCompiling and linking 23\nScope \n24\nControllers \n25\nTransclusion \n27\nSummary \n27\nChapter 4: Compile versus Link 29\nPeeking under the covers 29\nng-repeat \n31\nCompile \n31\nLink \n32\nWhat about linking? 36\nSummary \n36\nChapter 5: Keeping it Clean with Scope 37\nScope = false \n38\nScope = true \n40\nScope = {} \n41\n@ – read-only Access 41\n= – two-way binding 43\n& – method binding 44\nSummary \n47\nChapter 6: Controllers – Better with Sharing 49\nForms and inputs 49\nCreating our own controller communication 53\nSummary \n57\nChapter 7: Transclusion \n59\nThat's not a word... 59\n...it is a solution 60\nManipulating the transcluded content 62\nSummary \n64\nChapter 8: Good Karma – Testing in AngularJS 65\nGetting Started 65\nConfiguration?\n66\nAngular?and?Karma? 66\nMy first test \n68\nMocking data \n70\nThe test subject 71\nE2E testing \n72\nScenarios \n73\nSummary \n74\nTable of Contents\n[ iii ]\nChapter 9: A Deeper Dive into Unit Testing 75\nHighlighted, again 75\nNegative testing 77\nSummary \n80\nChapter 10: Bringing it All Together 81\nAngular content grid 82\nDiving in \n82\nThe initial directive 84\nConnecting Masonry 86\nTesting Masonry 88\nEvents \n89\nTiming \n91\nFurther steps \n92\nSummary \n92\nIndex \n93\n\nPreface\nAngularJS Directives  dives into the core building blocks of Angular.JS and provides \nyou with the knowledge you need to create fully dynamic web applications that \nrespond in real time to updates and changes in your data. You'll learn how to build \ndirectives from the ground up, as well as some of the best practices to use when \narchitecting them. By the end you'll be able to create a web application comprised \n \nof multiple modules all working together seamlessly to provide the best possible \nuser experience. What this book covers\nChapter 1 , Designing Web Applications in 2013 , provides a quick introduction to  \nsingle-page web applications and the current best practices for developing them.\nChapter 2 , The Need for Directives , discusses the value of Angular.JS directives and \nhow they satisfy many of the best practices discussed in \nChapter 1 , Designing Web \nApplications in 2013 . Chapter  3, Deconstructing Directives , highlights each of the configuration options \navailable for directives and provides examples of how they can be used.\nChapter 4 , Compile versus Link , dives into the two separate processes by which \nAngular.JS parses and transforms static HTML into a series of directives and \ndynamic elements. Chapter 5 , Keeping it Clean with Scope , serves as a study into the different degrees \n \nof scoping and isolation that AngularJS provides for its directives.\nChapter 6 , Controllers – Better with Sharing , discusses the advantages of using \ncontrollers to coordinate between parent and child directives.\nPreface\n[ 2 ]\nChapter 7 , Transclusion , provides an overview for consuming existing HTML content \ninto your directive while preserving the appropriate scopes.\nChapter 8 , Good Karma – Testing in Angular , introduces the Karma test-runner and \nprovides an overview of best practices for testing Angular applications.\nChapter 9 , A Deeper Dive into Unit Testing , dives deeper into the realm of unit testing \nand discusses the Angular approach to validating functionality.\nChapter 10 , Bringing it All Together , walks through the creation of a custom Angular.JS \ndirective from beginning to end. What you need for this book\nTo follow along with the examples, you'll need a standard text editor or IDE of your \nchoice. A basic web server such as Apache isn't required, but highly recommended, \nparticularly for the chapter on E2E testing. Some basic command-line knowledge is \nrecommended, but all the steps required will be explicitly written out within the text.\nWho this book is for\nThis book is intended for intermediate JavaScript developers who are looking to \nenhance their understanding of single-page web application development, with a \nfocus on Angular.JS and the JavaScript MVC framework. It is expected that you \n \nwill understand basic JavaScript patterns and idioms and can recognize JSON \nformatted data, however, no prior MVC or Angular.JS knowledge is required.\nConventions In this book, you will find a number of styles of text that distinguish between \ndifferent kinds of information. Here are some examples of these styles, and an \nexplanation of their meaning.\nCode words in text are shown as follows: \"With this approach, our \nJavaScript is nothing more than a function (attached to our element via \nng-\ncontroller=\"WidgetController\" ) that binds our tweets to a $scope  object \"\nA block of code is set as follows:\n$('#nextLink').click(function () {\n  $.get('api\/next', function (nextPage) {\n    displayPage(nextPage);\n  })});\nPreface\n[ 3 ]\nWhen we wish to draw your attention to a particular part of a code block, the \nrelevant lines or items are set in bold:\n<p ng-repeat=\"tweet in tweets\" tweet>\n  <!-- ng-click allows us to bind a click event to a function on the \n \n  $scope object -->   @{{tweet.author}}: {{tweet.text}} <span ng-  \n  click=\"retweet()\">RT<\/span> | <span ng-  \n  click=\"reply()\">Reply<\/span>\n<\/p>New terms  and important words  are shown in bold. Words that you see on the \nscreen, in menus or dialog boxes for example, appear in the text like this: \"clicking \nthe Next button moves you to the next screen\".\nWarnings or important notes appear in a box like this.\nTips and tricks appear like this.\nReader feedback\nFeedback from our readers is always welcome. Let us know what you think about \nthis book—what you liked or may have disliked. Reader feedback is important for \n \nus to develop titles that you really get the most out of.\nTo send us general feedback, simply send an e-mail to \nfeedback@packtpub.com , \nand mention the book title via the subject of your message.\nIf there is a topic that you have expertise in and you are interested in either writing \nor contributing to a book, see our author guide on \nwww.packtpub.com\/authors . Customer support\nNow that you are the proud owner of a Packt book, we have a number of things \n \nto help you to get the most from your purchase.\nPreface\n[ 4 ]\nDownloading the example code\nYou can download the example code files for all Packt books you have purchased \nfrom your account at http:\/\/www.packtpub.com . If you purchased this book \nelsewhere, you can visit http:\/\/www.packtpub.com\/support  and register to  \nhave the files e-mailed directly to you.\nErrata Although we have taken every care to ensure the accuracy of our content, mistakes \ndo happen. If you find a mistake in one of our books—maybe a mistake in the text or \nthe code—we would be grateful if you would report this to us. By doing so, you can \nsave other readers from frustration and help us improve subsequent versions of this \nbook. If you find any errata, please report them by visiting \nhttp:\/\/www.packtpub.\ncom\/submit-errata , selecting your book, clicking on the \nerrata  submission  form link, \nand entering the details of your errata. Once your errata are verified, your submission \nwill be accepted and the errata will be uploaded on our website, or added to any list of \nexisting errata, under the Errata section of that title. Any existing errata can be viewed \nby selecting your title from http:\/\/www.packtpub.com\/support . Piracy Piracy of copyright material on the Internet is an ongoing problem across all media. \nAt Packt, we take the protection of our copyright and licenses very seriously. If you \ncome across any illegal copies of our works, in any form, on the Internet, please \nprovide us with the location address or website name immediately so that we \n \ncan pursue a remedy. Please contact us at copyright@packtpub.com  with a link to the suspected  \npirated material. We appreciate your help in protecting our authors, and our ability to bring \n \nyou valuable content. Questions You can contact us at questions@packtpub.com  if you are having a problem  \nwith any aspect of the book, and we will do our best to address it.\nDesigning Web  Applications in 2013\nThe goal of this chapter is to provide a quick introduction to some principles that \nwill help you create high quality code, specifically aimed at frontend web application \ndevelopment. For a fuller study, I strongly recommend the article, \nPatterns For   \nLarge-Scale JavaScript Application Architecture\n, by Addy Osmani . An overview of good code\nIf you're reading this book, I'm going to assume you've done at least some \nprogramming work yourself, likely more than a little. During that time, I hope \nyou've had the chance to see some great code. Perhaps it was your own, but more \nlikely, at least for the first couple times you glimpsed it, it was someone else's \nmasterpiece. You probably didn't necessarily know what made it great; you just \nknew that it was far better than anything you had ever been able to extract \n \nout of a keyboard. On the other hand, almost anyone can identify bad code (unless it's their own, but \nthat's a whole different book). The logical holes, the ignored errors, the horrifyingly \ninconsistent indentation; we've seen it all, often with our own name attached to the \nfile, but somehow transforming that spaghetti mess into anything resembling those \nworks of art that we'd previously marveled at continues to escape us. This book \n \nisn't about beautiful code, but it is about a framework which flexes its muscles \n \nmost effectively when wielded in a manner optimized for frontend applications, \n \nand as such it's worthwhile for us to spend a chapter discussing some of the best \npractices for modern frontend web development.\nDesigning Web Applications in 2013\n[ 6 ]\nFor the purposes of our overview, we'll look at two basic tenets: \nmodularity  and \ndata driven development . Before we examine those, however, I want to use the next \nsection to address a common misunderstanding about frontend web development: \nadding more APIs is not always the answer.\nWe're not just talking about a lot of APIs\nOften, when a  backend developer first begins working on a frontend project, they \nbelieve that they can simply create an awesome API in the backend, call it with the \nfrontend code, and have a complete frontend web application. When I first started \ndeveloping frontend web applications, I wrote a lot of code that looked like the \nfollowing: $('#nextLink').click(function () {\n  $.get('api\/next', function (nextPage) {\n    displayPage(nextPage);\n  })});While the frontend technically handles both the user interaction (\n$('#nextLink').\nclick() ), and the display ( displayPage(nextPage) ), the real driver here is the \nbackend API. The API handles the logic, the state, and makes nearly all the decisions \nabout how the application should actually function.\nIn contrast, the frontend applications built on top of data modeling frameworks \nallow us to move away from that paradigm and instead position the client-side \n \ncode as the primary driver. This is awesome for two reasons:\n1. It allows modern web developers to do 90 percent of the coding in the same \nlanguage. This creates the potential for more code reuse, easier debugging, \nand all-round more efficient development, since even developers who speak \nboth client and server-side languages fluently will lose some momentum \nwhen they have to switch between them.\n2. The user experience vastly improves when everything we need to run the \napplication is already downloaded and available. Because the majority of \nthe logic and application processing is done client side, we are no longer \ndependent upon network requests or additional downloads before moving \nthe user forward. And as the JavaScript engines in all modern browsers get \ncontinually faster with each release, even computationally intense processes \nare becoming less and less of a limiting factor.\nChapter 1\n[ 7 ]\nThese reasons can make a significant difference in even the smallest of applications, \neven if it's only in your own peace of mind while developing. As you begin to tackle \nlarger projects, however, especially if you're working on a distributed team, modular \ncode that all builds on top of the same data-model becomes mission-critical; without \nit, each bit of functionality might expect a different property, flag, or (brace yourself) \nclassname to represent the appropriate state for your application. In contrast, when \nyour code is data-driven, everyone can work off the same built-in value map, \nallowing different pieces to connect far more seamlessly.\nNow that we've clarified what frontend development isn't, let's gets back to the \n \nkey principles that lead to great frontend application code.\nModularity The principle of modularity is hardly specific to frontend web applications, and most \ndevelopers these days recognize its usefulness, so I won't spend a lot of time here, \nbut it's worth a quick overview.\nThe primary goal of modularity is to ensure that the code you write can be reused \nin different parts of the same application, or even in different applications entirely, \nwithout requiring extensive re-architecting. This also helps ensure that a change to \nthe internal logic of one feature doesn't negatively impact the functionality of any \nother. In his article, Patterns For Large-Scale JavaScript Application Architecture\n, Addy \nOsmani  describes it as: Decouple app. architecture w\/module,facade & mediator patterns. Mods publish \nmsgs, mediator acts as pub\/sub mgr & facade handles security.\nIn non-twitter speak, the basic goal is to make sure each feature\/module keeps \ntrack of its own data\/state\/existence, is not dependent on the behavior of any other \nmodule to perform its own functionality, and uses messages to alert other modules \nto its own changes and appropriately respond to the changes of others.\nWe'll dive into modularity in great detail in the coming chapters, as it's one of the \ncore principles of Angular Directives, so for now we'll leave this summary here, \n \nand continue to the next key principle for frontend web applications.\nDesigning Web Applications in 2013\n[ 8 ]\nData driven development\nThere are several different X-driven development ideologies in the world of \nsoftware and web development, test-driven and behavior-driven being two of the \nmost popular. data driven development  (DDD from here on out) doesn't preclude \nany of these, and actually works simultaneously with many of them quite easily. \nDDD simply means using the structure of the data (or the model) as the foundation \nfrom which you build and make all other development design decisions. This is \nmost easily explained by looking at an example, so let's start here, and then we will \nreverse the process to create a new application in the coming chapters.\nIn this example, we've created the quintessential frontend widget, a twitter feed \ndisplay. This also serves as a good moment to highlight that not all web applications \nhave to fill the entire page. Often, a web app is a simple widget like this, possibly \nsomething that can be embedded in third-party sites, and while there are some \ndifferences in structure, the basic organization and guidelines are still the same.\nFirst, a quick snippet of some JSON data\n that we might use for this widget  \n(we won't worry about the actual retrieving of data from Twitter right now):\n[  {    \"author\" : \"mrvdot\",\n    \"text\" : \"Check out my new Angular widget!\",\n  },  {    \"author\" : \"mrvdot\",\n    \"text\" : \"I love directives!\"\n  }  ...]The HTML: <div ng-controller=\"WidgetController\">\n  <h3>My Tweets<\/h3>   <p ng-repeat=\"tweet in tweets\">\n    @{{tweet.author}}: {{tweet.text}}\n  <\/p> <\/div>\nChapter 1\n[ 9 ]\nAnd finally the JavaScript:\nfunction WidgetController ($scope) {\n  $scope.tweets = [];\/\/loaded from JSON data above\n}While the preceding example does operate within the Angular framework, the basic \nstructure here is representative of all good frontend architectures.\nLet's first take a high-level view of what's happening here. The first thing to note is \nthat the data itself is most important. I listed it first not because it was shortest, but \nto illustrate that the data is the foundation from which the rest of the code evolves. \nAfter the data, we move onto the HTML. This is most applicable in Angular, though \nit applies to other frameworks as well. In this model, once we have the data, we use \nthe HTML to describe the view, how we want to display the data, and also (jQuery \naficionados, brace yourselves) how we want the user to interact with that data. Only \nthen, at the end, do we write the little JavaScript code needed to glue it all together \n \nas the controller. From here, let's walk through it stepwise to see how everything \nworks together. Loading the data\nWhen we first initialize our application, the first thing we need to do is load our data. \nIn Angular, this is most commonly done through a service, which, while a vital part \nof Angular development, is outside the scope of this book. For now, let's just assume \nthat we've already loaded  our data into $scope.tweets . We'll dissect $scope  in great \ndetail later in Chapter 5 , Keeping it Clean with Scope , so for the purpose of this example, \njust know that it serves as the link between the view and our data.\nStructuring our HTML\nLet's revisit the main  element of our widget, the tweet paragraph tag:\n  <p ng-repeat=\"tweet in tweets\">\n    @{{tweet.author}}: {{tweet.text}}\n  <\/p>The first part of the HTML code uses the \nng-repeat  attribute to declare (again, \nremember we're building our HTML on top of the data-model, not receiving a \n \nmodel and remolding the HTML to reflect it) that we want to iterate through the \narray of tweets and print out for each the author's handle and their tweets in a \nparagraph tag.\nDesigning Web Applications in 2013\n[ 10 ]\nAdding JavaScript\nFinally, because  we've focused on building the HTML on top of the data itself, \n \nour JavaScript  is only a few lines:\nfunction WidgetController ($scope) {\n  $scope.tweets = [];\/\/loaded from JSON data\n}With this approach, our JavaScript is nothing more than a function (attached to \n \nour element via ng-controller=\"WidgetController\" ) that binds our tweets to  \na $scope  object. We'll discuss the specifics of scopes and controllers later, for now \njust know that the scope serves as a bridge between the controller and our HTML.\nConsider how we might have done this with jQuery (or a similar DOM manipulation \nlibrary). First we'd have to iterate through all of the tweets and build the HTML \nstring to insert into the message list. Then we'd need to watch for any new changes \nto our tweet array, at minimum append or prepend new items, or possibly rebuild \nthe entire list if we can't rely on all our tweets coming in order.\nDon't misunderstand, jQuery  is an amazing library, and we'll go into extensive \n \ndetail about how to use it in conjunction with Angular in the chapter on linking. \n \nThe problem, however, is that jQuery was never designed to be a data-model \ninteraction layer. It's great for the DOM manipulation, but trying to keep track \n \nof the DOM and the data at the same time gets tricky very quickly, and as anyone \nwho has previously built an application using this structure can attest, adequate \ntesting is nearly impossible. Summary Hopefully by now you're beginning to see that frontend web applications are far \nmore than just a collection of Ajax calls with a master backend still running the show. \nAnd as such, principles such as modularity and data driven development are vital \nto successful and efficient development. Modularity helps us plug features together \nwithout worrying about undocumented interactions breaking our entire app. And \nDDD ensures that every bit of our code stands on the foundation of the data-model \nitself, so we can be confident that the user's view and interactions accurately reflect \nthe true state of the application.\nIf you're still not convinced about everything, that's ok, we'll explore both of these \nprinciples in more detail throughout the coming chapters. For now, though, let's \n \ntake the next chapter to explore what distinguishes Angular.JS from many of the \nother common JavaScript MVC frameworks available today.\nThe Need for Directives\nThis chapter could almost as easily be titled \"The Need for Angular\", as directives \nmake up the heart and soul of what distinguishes Angular from other JavaScript \nlibraries and frameworks. Certainly there are other key features, Dependency \nInjection being one of my favorites that makes it exemplary, however none are \n \nquite as foundational to Angular as directives.\nWith that in mind, let's take a look at what attributes define directives and why \nthey're best suited for frontend development, as well as what makes them different \nfrom the JavaScript techniques and packages you've likely used earlier. Hopefully, \n \nby the end you'll understand a few of the key qualities that make directives ideal \n \nfor frontend web development. What makes a directive a directive\nAngular directives  have several distinguishing features, but for the sake of simplicity \nwe'll focus on just three in this chapter. In contrast to most plugins or other forms of \ndrop-in functionality, directives are \ndeclarative , data driven , and conversational .\nDirectives are declarative\nIf you've done any  JavaScript development before, you've almost certainly\n used \njQuery (or perhaps Prototype), and likely one of the thousands of plugins available \nfor it. Perhaps you've even written your own such plugin. In either case, you \nprobably have a decent understanding of the flow required to integrate it. \n \nThey all look something like the following code:\n$(document).ready(function() {\n  $('#myElement').myPlugin({pluginOpts});\n});\n[ 12 ]\nIn short, we're finding the DOM element matching \n#myElement , then applying our \njQuery plugin to it. These frameworks are built from the ground up on the principle \nof DOM manipulation. In contrast, as you may have noticed in the previous chapter, \nAngular directives are declarative, meaning we write them into the HTML elements \nthemselves. Declarative programming means that instead of telling an object how \nto behave (imperative programming), we describe what an object is. So, where in \njQuery we might grab an element and apply certain properties or behaviors to it, \nwith Angular we label that element as a type of directive, and, elsewhere, maintain \ncode that defines what properties and behaviors make up that type of object:\n<html>   <body>     <div id=\"myElement\" my-awesome-directive><\/div>\n  <\/body> <\/html> At a first glance, this may seem rather pedantic, merely a difference in styles, but as \nwe begin to make our applications more complex, this approach serves to streamline \nmany of the usual development headaches.\nConsider again our example of the tweet list from the previous chapter. In a \nmore \nfully developed application, our messages would likely be interactive, and in \naddition to growing or shrinking during the course of the user's visit, we'd want \nthem to be able to reply to some or retweet themselves. If we were to implement this \nwith a DOM manipulation library (such as jQuery or Prototype), that would require \nrebuilding the HTML with each change (assuming you want it sorted, just using \n.append()  won't be enough), and then rebinding to each of the appropriate elements \nto allow the various interactions.\nIn contrast, if we use Angular directives, this all becomes much simpler. As before, \nwe use the ng-repeat  directive to watch our list and handle the iterated display of \ntweets, so any changes to our scoped array will automatically be reflected within the \nDOM. Additionally, we can create a simple tweet directive to handle the messaging \ninteractions, starting with the following basic definition. Don't worry right now \nabout the specific syntax of creating a directive, we'll cover that more in the next \nchapter; for now just take a look at the overall flow in the following code:\nangular.module('myApp', [])\n  .directive('tweet', ['api', function (api) {\n    return function ($scope, $element, $attributes) {\n      $scope.retweet = function () {\n        api.retweet($scope.tweet);\/\/ Each scope inherits from it's \n \n  parent, so we still have access to the full tweet object of {\n \n  author : '…', text : '…' }\n      };\n[ 13 ]\n      $scope.reply = function () {\n        api.replyTo($scope.tweet);\n      };     }  }]);For now just know that we're getting an instance of our Twitter API connection and \npassing it into the directive in the variable \napi, then using that to handle the replies \nand retweets. Our HTML for each message now looks like the following code:\n<p ng-repeat=\"tweet in tweets\" tweet>\n  <!-- ng-click allows us to bind a click event to a function on the \n \n  $scope object -->   @{{tweet.author}}: {{tweet.text}}  \n  <span ng-click=\"retweet()\">RT<\/span> |  \n  <span ng-click=\"reply()\">Reply<\/span>\n<\/p>By adding  the tweet attribute to the paragraph tag, we tell Angular that this \nelement \nshould use the tweet directive, which gives us access to the published methods, as \nwell as anything else we later decide to attach to the \n$scope  object. \nDirectives in Angular can be declared in multiple ways, including \nclasses and comments, though attributes are the most common. We'll \ndiscuss the pros and cons of each method in the next chapter.\nScoping within directives is simultaneously one of the most powerful and most \ncomplicated features within Angular, so we'll spend all of \nChapter 5 , Keeping it Clean \nwith Scope  on it, but for now it's enough to know that every property and function we \nattach to the scope is accessible to us within the HTML declarations.\nDirectives are data driven\nWe talked in the previous chapter about how important being data driven is \n \nfor frontend applications. Angular directives are built from the ground up with \n \nthis philosophy. The scope and attribute objects accessible to each directive form \n \nthe skeleton around which the rest of a directive is built and can be monitored \n \nfor changes both within the DOM as well as the rest of your JavaScript code.\n[ 14 ]\nWhat this means for developers is that we no longer have to constantly poll for \nchanges, or ensure that every data change that might have an impact elsewhere \nwithin our application is properly broadcast. Instead, the scope object handles all \ndata changes for us, and because directives are declarative as well, that data is \nalready connected to the elements of the view that need to update when the data \nchanges. There's a proposal for ECMAScript 6 to support this kind of data watching \nnatively with Object.observe() , but until that is implemented and fully \n \nsupported, Angular's scope provides the much needed intermediary.\nDirectives are conversational\nAs we discussed in the  previous chapter, modular coding emphasizes the use of \nmessages to communicate between separate building blocks within an application. \nYou're likely familiar with DOM events, used by many plugins to broadcast internal \nchanges (for example, save, initialized , and so on) and subscribe to external \nevents (for example, click, focus, and so on). Angular directives have access to \nall those events as well (the $element  variable you saw earlier is actually a jQuery \nwrapped DOM element), but $scope  also provides an additional messaging system \nthat functions only along the scope tree. The \n$emit and $broadcast  methods \nserve to send messages up and down the scope tree respectively, and like DOM \nevents, allow directives to subscribe to changes or events within other parts of the \napplication, while still remaining modular and uncoupled from the specific logic \nused to implement those changes.\nIf you don't have jQuery included in your application, Angular \nwraps the element in jqLite, which is a lightweight wrapper that \nprovides the same basic methods.\nAdditionally, when you add in the use of Angular services, which aren't the focus \nof this book but we'll touch on briefly in the next chapter, directives gain an even \ngreater vocabulary. Services, among many other things, allow you to share specific \npieces of data between the different pieces of your application, such as a collection \n \nof user preferences or utility mapping item codes to their names. Between this shared \ndata and the messaging methods, separate directives are able to communicate fully \nwith each other without requiring a retooling of their internal architecture.\n[ 15 ]\nDirectives are everything you've dreamed \nabout Ok, that might be a bit of hyperbole, but you've probably noticed by now that the \nbenefits outlined so far here are exactly in line with the best practices we discussed \nin the previous chapter. One  of the most common criticisms of Angular is that it's \nrelatively new (especially compared to frameworks such as Backbone and Ember). In \ncontrast, however, I consider that to be one of its greatest assets. Older frameworks \nall defined themselves largely before there was a consensus on how frontend \nweb applications should be developed. Angular, on the other hand, has had the \nadvantage of being defined after many of the existing best practices \n \nhad been established, and in my opinion provides the cleanest interface between \n \nan application's data and its display.\nAs we've seen already, directives are essentially data driven modules. They allow \ndevelopers to easily create a packageable feature that declaratively attaches to an \nelement, molds to fit the data at its disposal, and communicates with the other \ndirectives around it to ensure coordinated functionality without disruption of \nexisting features. Summary In this chapter we learned about what attributes define directives and why they're \nbest suited for frontend development, as well as what makes them different from \n \nthe JavaScript techniques and packages you've likely used before. I realize that's a \nbold statement, and likely one that you don't fully believe yet. That's ok, we still have \nnine more chapters to go. Next we'll spend some time discussing just how to go about \ncreating a directive and what some of the options mean, and hopefully you'll begin to \nsee just how flexible, yet powerful, these directives can be.\n\nDeconstructing Directives\nAnd without further ado: Directives! Now that we've had the chance to discuss \n \nsome of the whys of directives, let's get on with the hows. In this chapter, we'll go over \neach of the different configuration options you have at your disposal while creating \n \na directive, as well as when each property is most helpful. Hopefully by the end of this \nchapter you'll begin to have a better understanding of what actually happens when we \nadd a directive to an element and be excited to dive into some of the more powerful, \nbut complex, configurations possible that are coming in the following chapters.\nGetting started\nIf you've worked with Angular before, feel free to skip the next section, it's simply \n \na review of how to set up an Angular.JS application and import other modules. \n \nWe'll get into the specifics of directives in the \nWith directives  section.\nWith Angular An Angular.JS application  is first brought to life using the \nangular.module  \ncommand, which is actually much more powerful than what we'll cover here. \n \nFor the purpose of our text, we'll simply look at how to create a module and how \nto include other modules as you need. For a fuller read, the documentation on \nangularjs.org  is actually pretty robust at http:\/\/docs.angularjs.org\/guide\/\nmodule .Angular  uses modules to separate different pieces of your application for easier \ntesting and modularity. The recommended approach is to have separate modules \n \nfor your services, directives, and filters, and one application-level module that \nimports all of them and then executes your initialization code, if any.\nWith this in mind, here's a quick example of what it looks like, and then we'll walk \nthrough it.\nDeconstructing Directives\n[ 18 ]\nFirst, the JavaScript needed to initialize our module:\nangular.module('myApp', ['myApp.directives']);\nangular.module('myApp.directives', []);\nThen the HTML code that tells Angular we want our page to be dynamically \ncontrolled: <html ng-app=\"myApp\">   <head><\/head>   <body><\/body> <\/html> A couple points to notice.\n1. First, we don't need to wrap  the angular.module  statements within any  \nsort of the $(document).ready()  event listener. As long as the module file \n \nis loaded after Angular itself, Angular takes care of making sure everything \nis ready before charging forward.\n2. Secondly, in that same vein, note that we can actually require a module \nbefore it's loaded. The array passed in as the second parameter to \nangular.\nmodule  tells Angular what other module(s) should be required before \ninitializing our new module, and in our case here, the directives module \nactually comes after our main myApp module (and could be in an entirely \ndifferent file, loaded several requests later), however Angular waits until \n \nall the modules have been loaded before initializing any of them.\n3. Finally, we use yet another directive, \nng-app  to tell Angular that this module \nis our primary module, please initialize it and then parse all the nodes within \nit. The ng-app  directive  can be attached to any DOM node, however, unless \nyou're creating a small widget to be embedded within a different application, \nmost commonly you'll want to use it on the \nhtml node itself.\nAt the time of writing, when developing for Internet Explorer 8 & 9 \nbrowsers, the ng-app directive must be declared twice if you attach it \nto the html node. In addition to using the attribute to declare which \nmodule to use, you must also add the id tag of \"ngApp\", otherwise IE \nwon't notice it during the bootstrap process.\nAs a closing note, for convenience' sake, Angular allows you also to retrieve a \nmodule by calling angular.module  with just the name parameter (that is \nangular.\nmodule('myApp') ), which can be helpful if you want to attach additional directives \nor other configurations to a directive in a separate file, or perhaps conditionally \nbased on your environment variables.\nChapter 3\n[ 19 ]\nWith directives\nNow that you have a  basic understanding of how to initialize an Angular module, \nlet's extend our directives module to demonstrate how to declare a directive within \nour code as shown: …angular.module('myApp.directives', [])\n  .directive('myAwesomeDirective', function (){});\nObviously, this directive won't do much (and will actually throw an error if you \ntry to use it because it's not complete yet), but this, in a nutshell, is how you create \na directive. The .directive  method on each module is actually a shortcut method \nto the same method on compileProvider , which you can use within a module's \nconfiguration block, but that's outside the goals of this book.\nAs mentioned earlier, our directive, as it stands right now, will actually throw \nan error if you try to attach it to a node, which is because Angular recognizes the \ndirective, but doesn't know what to do with it. The function that makes up the \nsecond parameter isn't actually the directive definition in itself, but rather a factory, \nused to create the directive. This is a pattern common within Angular, and you'll see \nit used in controllers, services, and filters when you go on to create those. What this \nmeans is that the first time Angular needs to initialize your directive, it executes this \nfactory function, then stores the result for all the future instances of the directive. \nAs such, it's what we return from this factory function that actually determines the \ndirective's configuration. This can be a bit confusing to discuss, but hopefully will \nmake more sense as we continue our example as shown:\n…angular.module('myApp.directives', [])\n  .directive('myAwesomeDirective', ['api', function(api) {\n    \/\/Do any one-time directive initialization work here\n    return function($scope, $element, $attrs) {\n      \/\/Do directive work that needs to be applied to each \n \n  instance here     };   }]);\nDeconstructing Directives\n[ 20 ]\nWithin your factory function, you can either return another function, as we did \nhere, or a configuration object, which we'll go over in detail later in this chapter. \nThe function accepts the current scope for the instance of that directive, the jQuery \nwrapped DOM element, and any attributes attached to the element as parameters, \nand often that will be all you'll need to use for your directive. This function gets \ncalled each time the directive is attached to a DOM element and can be used to \n \nattach plugins, retrieve additional data, and so on.\nAngular  provides multiple ways to handle Dependency Injection, \nbut two are the most common. In many examples, you'll see factory \nfunctions that look like function($scope, $http) { … } , which \nworks because Angular will actually inspect the variable names to \ndetermine what providers it should use, then inject those into the \nfunction, so $scope  gets populated with an instance of the current \nscope, and $http gets the singleton instance of Angular's \n$http \nlibrary. This is awesome, until you try minimizing your code, because \nonce the variable names change, everything breaks. With that in mind, \nI recommend using the second approach, which requires passing in an \narray in place of the factory function, as we did earlier. In this case, you \nexplicitly name what instances you need (\napi in our case, these can be \nour own custom services\/filters in addition to those built into Angular), \nand then the last element in your array is the factory function itself, and \neach variable will be populated in the same order as your original array \nelements. This is the method I'll use throughout this book, and the one \nI recommend anytime you're writing code that you'll want to use in a \nproduction environment. Naming Naming of directives within Angular is pretty flexible, with a few conventions \nimplemented to ensure consistency. All directives are named using camelCase in \nJavaScript, and snake case within your HTML. Snake case, here, means all lower \ncase, using either :, -, or _ to separate the words. Thus, for us, the JavaScript name \nmyAwesomeDirective  becomes my-awesome-directive , my:awesome:directive ,  \nor my_awesome_directive  in the HTML, all of which will properly bind the \ndirective to the DOM node. And finally, if you're running your HTML through a \nvalidator and don't like seeing warnings about each of your custom directives, you \ncan even prepend x- or data- to the directive name and Angular will still detect it.\nChapter 3\n[ 21 ]\nAttachment styles\nNo, we're not talking about relationships here. Directives can be invoked from \n \nwithin your HTML in multiple ways, though it's up to the developer to decide \n \nwhich ones they will allow. When developing your own directive, you can control \nwhich methods you want to utilize through the \nrestrict  property, using a subset  \nof EACM (standing for element, attribute, class, comment).\nBy far, the most common method for invoking a directive is through an \nattribute , \nin large part because it's the default if the \nrestrict  property is left undefined. \nIt's the method you've seen me use so far in all the examples, and outside of this \nsection, all other examples we'll use this method as well. Declaring a directive via \nan attribute protects you from the issues we'll see shortly with Internet Explorer, \nand still provides a semantic indication within your HTML that you are declaring \nthe function or nature of this node. For a quick reminder, here's what the attribute \nmethod looks like: <div my-awesome-directive=\"something\"><\/div>\nThe next method that you're likely to see is using the directive name as the \nelement \nname itself. <my-awesome-directive><\/my-awesome-directive>\nThis method has the advantage of being exceptionally semantically accurate, and, \nlet's be honest, it looks the coolest because we're creating our own HTML elements. \nThe disadvantage, as usual, is that Internet Explorer will read these in as \ndiv \ninstances, thus preventing Angular from knowing that they even exist. You can get \naround this by using document.createElement('my-awesome-directive')  in the \nhead of your HTML, but you have to do this separately for each directive, and except \nin rare cases I usually consider it to be more work than it's worth.\nThe final two methods are classname  and comment . Both are very rarely used, \nalthough I do know some developers who prefer using comments because they feel \n \nit keeps their HTML cleaner.\n\/\/As a class <div class=\"my-awesome-directive: something;\"><\/div>\n\/\/As an HTML comment <!-- directive: my-awesome-directive something -->\nWhich method out of the four you use is almost entirely a matter of preference, \nthough conventions do lean toward attributes, and most directives you use from \nother developers will likely at least support that method, if not use it exclusively.\nDeconstructing Directives\n[ 22 ]\nConfiguration options\nNow that we have a good basis for how to create a blank directive and attach it to \nour DOM, let's take a look through the directive definition object, which is the official \nname for the object returned from the directive factory function. Remember that \nthere are two ways to initialize a directive within the factory function. The first is to \nreturn our linking function, as we did earlier, and the second is to use this definition \nobject to provide more fine-grained control over the way our directive functions. \nUsing the definition object, our directive with all the options enumerated looks like \nthe following code: angular.module('myApp.directives', [])\n.directive('myAwesomeDirective', ['api', function(api) {\n  \/\/Do any one-time directive initialization work here\n  return {     priority : 10,     terminal : false,\n    template: '<div><h3>{{title}}<\/h3><\/div>',\n    templateUrl : 'myDirective.html',\n    replace : true,     compile : function (element, attributes, transclude) {},\n    link : function ($scope, $element, $attrs) {},\n    scope : true,     controller : function ($scope, $element, $attrs) {},\n    require : 'myAwesomeDirective',\n    transclude : true\n  };}]);Obviously you'll never use all of these options at the same time, however, let's dive \ninto each one individually. Priority The first property we will look at is  the priority  option, which allows us to specify \nin what order directives should be executed, if there are multiple directives on the \nsame node. The default is 0, and unlike many languages, higher numbers go first \nhere. There is no specification for what order directives of the same priority will \nexecute in, so if order is really important, it's best to make that explicit.\nFor simple tasks like attaching some data or initializing a jQuery plugin on your \nelement, this option won't be necessary, however if your directive needs to modify \nthe DOM in any way, particularly if it needs to add in other directives conditionally, \nyou'll find this option exceptionally helpful.\nChapter 3\n[ 23 ]\nTerminal Closely tied to priority , terminal  dictates whether or not directive execution \nshould stop after the priority  level. It's important to note, however, that this does \nnot necessarily mean stop after this directive itself. Because the execution order of \ndirectives on the same priority level is not specified, directive processing continues after \na terminal directive until the end of its priority level, ensuring that the results will be \nconsistent. Like priority , this option is most useful in cases where conditional DOM \nmanipulation is needed, something we'll study in greater detail in the next chapter.\nTemplating If your directive provides a custom HTML structure, you can use the  template  \nor templateUrl  property to define it. These templates can also contain other \ndirectives nested within them, and those will be initialized and attached as part \nof your directive's compilation process as well. Both template properties function \nlargely in the same way, replacing the element's HTML with the specified template, \nalthough template  takes an inline string, whereas \ntemplateUrl  loads the HTML \nfrom an external file. Do note that the compile\/link process for this directive will \nbe suspended until the template is loaded, so if your custom HTML is minimal, it's \nusually more efficient to provide it inline.\nReplace Use of the  replace  property  specifies whether the whole element should be replaced \nwith the template, or if the template HTML should just replace the element's inner \nHTML. If you do choose to replace the entire element, note that Angular will do its \nbest to copy over all of the classes\/attributes from the original element, including \nmerging the class attributes together. Additionally, if you want to replace the original \nelement, your template must have only one root node. If you try to use a template \nwith multiple root nodes (such as <h2>{{title}}<\/h2><div>{{content}}<\/  \ndiv>), Angular will throw an error as there's no way to migrate the attributes \n \nover consistently. Compiling and linking\nThe compile  and link properties do the bulk of the DOM manipulation and the \nplugin binding work. We'll spend all of the next chapter discussing why the process \nis split into two parts like this, and when to use each. For the sake of an introduction, \nand as a massive over-simplification, you can think of \ncompile  as performing any \ntasks that require restructuring the DOM (and possibly adding other directives) \nregardless of the specific scope, and the link function as attaching a scope to that \ncompiled element.\nDeconstructing Directives\n[ 24 ]\nRemember that we said you could return a function directly from the factory \nfunction, instead of using this definition object? That function that we return is \nactually the link function discussed here, and is simply a shortcut to returning \n \na definition object with only link defined.\nOne last important note on these properties, and then we'll save the rest for the \nnext chapter. If you set a value for the  compile  property, Angular will ignore the \nlink property. If you need to use both, you can return an object from the \ncompile  \nfunction, with pre set to your compile  function, and post set to your link function, \nas demonstrated in the following code:.\nangular.directive('myAwesomeDirective', function () {\n      return {       compile : function (tElement, tAttrs, transclude) {\n        pre : function compile ($scope, $element, $attrs) {},\n        post : function link ($scope, $element, $attrs) {} \n \n        return{       ...\/\/current pre and post text\n      }     }  }});Scope As mentioned in Chapter 2 , The Need for Directives , scoping with directives is one  \nof the most powerful, yet confusing features of Angular, so we've dedicated all \n \nof Chapter 5 , Keeping it Clean with Scope , to it. For now, let's just take a quick look \n \nat the three types of values the \nscope option can have.\nIf left undefined, the scope value is null, which tells Angular to give the directive \n \nthe same scope as the object its attached to. This is by far the most common case, \n \nand is perfect for adding a few new values to watch as we did in the previous \nchapter. If, however, you want to generate a new scope for your directive, there \n \nare two ways you can do so.\nFirst, simply set the scope parameter to \ntrue, which will create a new scope for  \nthe directive, but still inherit from it's parent. This means you'll still be able to \n \nread all of the values from your parent scope, including adding any new watchers \n \nto monitor data changes, but new values you write onto the scope won't affect \n \nthe parent scope's values.\nChapter 3\n[ 25 ]\nNote, this is a bit of an over generalization, as it's simply inherited \nfrom it's parent prototypically, like all other JavaScript objects. Which \nmeans if you set $scope.name = “bob”  on the child scope, the \nparent won't be touched. If instead, however, you set \n$scope.data.\nname = “bob” , it will be changed, as you're actually reading the \n“data”  object first, then setting the value on that, and since that object \nis shared between parent and child, both will reflect the change.\n$scope.name = “bob” $scope.data.name = “bob”\n“data” Secondly, if you want to isolate your directive from the rest of your application, \nyou can create an aptly named isolate scope . This scope can be helpful in ensuring \nmodularity and preventing accidental changes to data outside of your directive \ncaused by shared properties or methods.\nTo create an isolate scope, simply pass in an object hash to the scope parameter. If it's \nempty, no values will be inherited and your scope will be completely isolated. You \ncan also specify specific properties and attributes that you want to maintain access \nto, which we'll explore in Chapter 5 , Keeping it Clean with Scope .\nAs a final note on scope for this chapter, each DOM element can only have one scope \napplied to it, which means that if you set \nscope : true  for multiple directives on \nthe same node, they'll all share the same new scope. While this is usually fine, do \nnote that only one directive on a node can request an isolate scope, and all other \ndirectives will share that scope, so be careful with declaring an isolated scope too \noften, particularly if you intend to share this module with other developers who \nmight need to isolate their own directives as well.\nControllers The next two properties, controller  and require , are closely related, so we'll look \nat them together. The controller  function  can store many of the same properties or \nmethods that you might normally attach to the scope discussed earlier, however, if \nthey are attached to the controller itself, they can be shared with other directives in \nthe DOM tree. This sharing is done via the \nrequire  property, which tells Angular \nto grab the instance of one directive's controller and make it available to another \ndirective. As with much of Angular, this is somewhat complex to discuss in text, so \nlet's take a look at an example of requiring an instance of \nngModel , one of the most \ncommon controllers you'll request, as it's the basis for all two-way data binding. \n \nTo start, here's the basic directive definition:\nDeconstructing Directives\n[ 26 ]\nangular.directive('autocompleteInput', function () {\n  return {     require : 'ngModel',\n    link : function ($scope, $element, $attrs, ngModel) {\n      ngModel.$render = function () {\n        $element.val(ngModel.$viewValue || '');\n      };       $element.autocomplete({\n        … \/\/Define source, etc\n        select : function (ev, ui) {\n          $scope.$apply(function() {\n            ngModel.$setViewValue(ui.item.value);\n          });         }       });     }   }});Here we have an example of a simple directive that attaches the jQueryUI \nautocomplete plugin to an input, and handles updating the model when a selection \nis made. You can see we've used the \nrequire  property  to tell Angular that we want \naccess to the controller instance on the \nngModel  directive, which then gets passed \ninto our link function as the fourth parameter. Because we've required the \nngModel  \ncontroller, we also have to declare the directive that provides that controller, \notherwise Angular will throw an error, which means that our input element needs to \nlook something like this:\n<input ng-model=\"data.property\" autocomplete-input \/>\nObviously, throwing an error is often not what we want to happen, so Angular \nallows you to prepend a question mark, such as \n?ngModel , to make that requirement \noptional. You can also use a caret (\n^ngModel ), to tell Angular to traverse upwards \nfrom the element node through the DOM tree and look for the directive in the \nelements there, such as the following:\n<div ng-model=\"data.property\">\n  <input autocomplete-input \/>\n<\/div>The ngModel  controller provides multiple methods and properties, but for our \npurposes we only need two, $render  and $setViewValue() . The ngModel  directive \ncalls $render  whenever the value of the data element that it's bound to (\ndata.\nproperty  in the preceding code) changes. Thus, once we assign our custom function \nto the $render  key, any time the data changes, we can update the input value \nappropriately. $setViewValue  works in the opposite direction, so when the user \ndoes something that should change the value, we can tell \nngModel  what the new \nvalue is and it will update the internal data model.\nChapter 3\n[ 27 ]\nIf you need access to multiple controllers, you can also pass in an array to the \nrequire  property, and likewise the fourth parameter of your \nlink function will be \nan array of those controllers.\nDefining your own controller is a bit outside the scope of this chapter, so we'll revisit \nthat later in Chapter 6 , Controllers – Better with Sharing . Transclusion Just like the previous few sections, the \ntransclude  property deserves its own \nchapter, and so we'll explore it more in \nChapter 7 , Transclusion . In short, transclusion \nprovides the ability to have an isolate scope \nas we discussed earlier, and still have \naccess to the parent scope's properties for internal content. If that doesn't make any \nsense, that's normal, even the developers of Angular themselves concede that:\nThis may seem to be a unexpected complexity, but it gives the widget user and the \ndeveloper the least surprise.\nhttp:\/\/docs.angularjs.org\/guide\/directive\nWhile indeed providing helpful functionality, for most directives, transclusion\n is \nsimply too much complexity for what we need, and thus we're going to leave it \n \nalone until Chapter 7 , Transclusion . By that point, you'll hopefully be more \ncomfortable with the more core attributes of directives.\nSummary Hopefully by this point I've whetted your appetite by elaborating on some of the \npower that each directive can utilize. The simpler properties such as template, \npriority, and basic linking should already have demonstrated a taste of the kind of \nmodular extensibility directives can add to your development arsenal. And we'll \nrevisit each of these properties over the next several chapters as we dive into the \ninner workings of scoping, controllers, and transclusion, as I recognize many of the \noptions discussed likely still seem like a magic black box. Next, however, let's take a \nlook at some of Angular's built in directives, \nng-repeat  and ng-switch , for a study \ninto why we separate compile  and link, and how you can use that for your own \ncustom directives as well.\n\nCompile versus Link\nWithin Angular directives, there are two primary phases that handle the process of \nconnecting the directive logic to the DOM, as well as performing any necessary DOM \nmanipulation. The first phase is the compile phase , which works on the element \nbefore it's been inserted into the document, and thus is great for performance, but \ncan't be used to attach any DOM related plugins since the element isn't accessible yet. \nThe second phase is the linking  phase, which works on the element after it has been \ninserted into the DOM and has the appropriate scope instance created and initialized \nfor it. For this chapter, we'll start by reviewing a couple directives built into Angular \nas an example of why this separation exists and how it can best be used, and then \nwe'll create a few of our own examples to explore it in more detail.\nPeeking under the covers\nLet's first take a quick look at what Angular \nactually does with the  functions it \nreceives from the compile  and link properties, and how they're used during the full \ncompilation process. The first thing to know is that both returning a function from our \ndirective factory (instead of using the definition object) and defining a function on the \nlink parameter are really just shortcuts to setting the compile property to be a function \nthat returns that same linking function. In other words, no matter how we define our\n \nlink function, by the time Angular gets around to processing our directive, it will \nalways call the compile function and take what it returns as the linking function(s). \n \nFor proof, here are few lines of code that make that initial call:\n...linkFn = directive.compile($compileNode, templateAttrs,\n \n  childTranscludeFn);\n  if (isFunction(linkFn)) {\n    addLinkFns(null, linkFn);\n    \/\/Only attach to 'postLink' functions\n    }else if (linkFn) {\n    addLinkFns(linkFn.pre, linkFn.post);\n}\n[ 30 ]\nThere are a couple of important things to note from this code before we move on. \nFirst, compile is  called really early on during this whole process. \n$compileNode  \nrepresents the element we're manipulating, but it's not anywhere in the DOM just yet, \ninstead it's much like what you would receive if you called \njQuery  (<div>) . What \nthis means is while we can manipulate it within the compile function (and if we need \nto conditionally add other directives or change the pre-parsed\n HTML, this is where \nwe have to manipulate it), we can't attach any DOM listeners or plugins that need to \nprocess a fully-realized node just yet. Secondly, there are actually two types of linking \nfunctions, pre and post. When Angular is processing your directive, it will first execute \nany and all of the pre-linking functions on the directive element itself, then it will \nrecurse down into any child nodes within the element and compile those, then walk \nback up the DOM tree and execute all of the post-linking functions. As a result, \n \nthe whole compilation process proceeds through the following flow:\nmainDirective -compile fn -preLinking fn mainDirective -postLink fn firstChildDirective -compile fn -preLinking fnfirstChildDirective -postLink fnlastChildDirective -compile fn -preLinking fn -postLinking fn\nAs a general rule, the same DOM manipulation restrictions apply to both the compile \nfunction and the pre-linking function, since the element is still being updated by \nAngular and cannot be cloned or otherwise modified before creating the final instance \nthat will be inserted into the document. The post-linking function, on the other hand, \nreceives the final element and can be manipulated as you need. The majority of your \ndirectives will likely just use the post-linking function. The pre-linking function is \nonly advantageous when you need to perform some\n individualized preparation \non the scope or controller object before any child elements compile, so we'll review \nthat use case in more detail in Chapter 6 , Controllers–Better with Sharing . Compile, on \nthe other hand, is ideal when you need to make use of the transclusion function or \nconditionally modify your element before it's compiled, so we'll review a couple use \ncases of that in this chapter.\n[ 31 ]\nng-repeat To start our study into the primary use cases for the compile function, let's take \n \na look at the definition object for the built-in directive \nng-repeat . The definition  \nobject is as follows:\n....directive('ngRepeat', function () {\n  return {     priority: 1000,     transclude: 'element',\n    terminal: true,     compile: function(element, attr, linker) { \/\/ Compile Function\n      return function(scope, iterStartElement, attr){ \/\/ Linking \nFunction       };     }  }});The first few properties should be familiar from the previous chapter, but let's \nquickly review how each is used here. A \npriority  value of 1000 makes sure that \nthis directive executes before any others on the element, and setting \nterminal  to \ntrue ensures that Angular's automatic compilation doesn't continue on to any other \ndirectives on this element or its children. We want this because the \nng-repeat  \ncompile function itself will actually be handling the compilation processing for the \nnode tree of child elements. A transclude  value of element  is used to collect the \nHTML content of the original element, as we'll need that to be able to compile it \n \nlater and as such we'll see that it is used here shortly within the compile function.\nCompile The compile function declared in the preceding section takes three properties. The \nfirst is the template element, meaning it contains all the HTML within our DOM \nnode, but again, this doesn't necessarily represent the instance of that element \nthat's actually going to be inserted into our final document. The second property \nis similar to the $attrs  object that was passed to our linking function in \nChapter 3 , \nDeconstructing Directives . It contains normalized access to each attribute on the DOM \nelement. Remember, however, that we don't have an initialized scope here, so any \nof the attribute values that need to be evaluated within a scope won't have a useful \nvalue yet.\n[ 32 ]\nFor the purpose of our examination, however, the final parameter is by far the most \nvaluable. This linker is the transcluded function, which Angular would normally \nuse to attach a scope to this element, interpolate all of the values, and then insert the \nfinal object into the DOM. By grabbing this linking function, \nng-repeat  now has \ncontrol over when to perform the actual linking, as well as the ability to repeatedly \ndo so, which of course is exactly what we need.\nLink The linking function is what the compile function returns. Because, in the case of \n \nng-repeat , we only need to get access to the transcluding function, and not actually \ndo any DOM manipulation on the template element, we can just return \n \nthat immediately. At the heart of the ng-repeat linking function is $scope.$watch , which serves  \nto connect the data and data changes to the rest of our code. As a quick note of \nintroduction, the $watch  method's first argument can take two types of parameters. \nThe first type is a simple string that corresponds to a scoped variable and is \nevaluated against the current scope; this is the method you'll probably use most \ncommonly. The second type is a full function which takes the current scope as its \nown first parameter and allows for more complex comparisons. In both cases, any \ntime the return  value changes or is first initialized, the function passed in to \n$watch  \nas the second parameter is called. In our case here of \nng-repeat , we're actually \nusing the watcher  function (first parameter) to perform all of the necessary changes, \nsince it gets called every time Angular executes the \n$digest  function. As a note, I \nwouldn't actually recommend this method unless you're confident it's necessary and \nyou've extensively optimized your watcher  function, as this can get called several \ntimes a second. The actual internals of the $watcher  function are more complicated than it is \nworthwhile for us to dive into for the goals of this chapter, so we'll operate off this \nsimplified model for the purpose of our discussion.\ncompile: function (element, attrs, linker) {\n  return function ($scope, $element, $attrs) { \/\/ \"post\" Linking \nfunction     $scope.$watch(function ($internalScope) {\n[ 33 ]\n      $element.html('');\/\/ Clear the element's current HTML\n      var values = … \/\/ Read in array to iterate over\n      values.forEach(function (data, index) {\n        $internalScope.element = data; \/\/ Attach this element's data \nproperties to the 'element' property on the scope so we can use it \nwithin the template         linker($internalScope, function (clone) {\n          $element.append(clone); \/\/ Take the interpolated HTML and \nappend it to our main $element\n        }); \/\/ end of linker clone function\n      }); \/\/ end of forEach\n    }); \/\/ end of $watch\n  }; \/\/ end of linking function\n} \/\/ end of compile function\nObviously, we're setting aside some necessary caching and sorting methods, \nhowever for our purposes this represents the key process. We begin by reading in \nthe current values for our array, iterating over each element to assign it to our scope, \nand then performing magic.\nWell, almost magic. We're finally going to use that \nlinker  function we've been \nworking up to for this whole  section. Remember that we fetched this from the \ncompile property, which means it's imbued with all of the requisite knowledge \nof our directive template (if there is one), the internal HTML within our element \nnode, and is all but  salivating at the chance to show off its skills at scope binding \nand interpolation. And since it's never wise to disappoint an anxious function, \nwe're finally going to oblige it by sending in our newly crafted scope, along with a \nsecondary function to handle the result.\nWithin the linker  function, the scope gets bound to the compiled, but not yet \ninterpolated, element HTML, and a new \"fully transformed\" element is generated. \nThat element gets passed to our secondary function as the \nclone parameter, whereby \nwe use a little standard jQuery DOM manipulation to insert our \nclone element into \nthe DOM at the end of our original element.\nIn a (somewhat large) nutshell, that's how \nng-repeat  makes use of the compile \nproperty to transform an element DOM structure, not just once, but continuously \nas the data changes. Now let's continue and check out \nng-switch , another built-in \ndirective that makes use of the compile property, though in a slightly different way.\n[ 34 ]\nng-switch Since we've already covered attaching directives extensively, we're not going to \nexamine the HTML of an ng-switch  directive in detail. However, in the interest of \nhaving a reference point while going through the JavaScript, here's a simple example \nshown in the following code snippet:\n<div ng-switch=\"currentSport\">\n  <p ng-switch-when=\"baseball\">Home run!<\/p>\n  <p ng-switch-when=\"football\">Touchdown!<\/p>\n  <p ng-switch-default>Goal!<\/p>\n<\/div>For an unexpected  twist in the story, let's take a look at the \nng-switch  definition \nobject:{  restrict: 'EA',   require: 'ngSwitch',\n  controller: function () {\n    this.cases = {};   },  link: function(scope, element, attr, ctrl) {\n    var watchExpr = attr.ngSwitch, \/\/ Read in the data property we \nwant to monitor         selectedLinker,\n        selectedElement,\n        selectedScope;\n    scope.$watch(watchExpr, function (value) {\n      if (selectedElement) { \/\/ remove any prior HTML within $element\n        selectedScope.$destroy();\n        selectedElement.remove();\n        selectedElement = selectedScope = null;\n      }       if ((selectedLinker = ctrl.cases['!' + value] || ctrl.\ncases['?'])) {         selectedScope = scope.$new();\n        selectedLinker(selectedScope, function(caseElement) {\n          selectedElement = caseElement;\n          element.append(caseElement);\n        });       }     });   }\n[ 35 ]\nI warned you there was a twist, and you've likely already seen it... there's no compile \nproperty here. That's right; our next foray into this study of compilation doesn't \neven include a compile property on the main directive. That's because \nng-switch  is \nactually a collection of three different directives, all of which work together, and it's \non these other two directives that compile makes its shining appearance.\nThe two supplemental directives, ng-switch-when  and ng-switch-default , work in \nnearly the same way, and function just as you might expect if you have any experience \nwith switch statements in other languages. \nng-switch-when  serves to match against a \nspecific case, and display its associated element if a match is made. On the other hand, \nng-switch-default  comes into play if no matches can be found. Because they're so \nsimilar, we'll only look in depth at the code of \nng-switch-when , but I'll point out the \none place they differ just so you can have a fuller understanding of it. Without further \nado, let's have a look at the following ng-switch-when  directive:\n{  transclude: 'element',\n  priority: 500,   require: '^ngSwitch',\n  compile: function(element, attrs, linker) {\n    return function(scope, element, attr, ctrl) {\n      \/\/ For ng-switch-default, the linker function is simply attached \nto the '?' key within ctrl.cases\n      ctrl.cases['!' + attrs.ngSwitchWhen] = linker;\n    };   }}In the same manner as we just saw with \nng-repeat , we're once again setting the \ntransclude  property to element  in order to request an instance of the linking \nfunction. This time, however, we've also grabbed an instance of the \nngSwitch  \ncontroller. We'll talk more about controllers in \nChapter 6 , Controllers–Better with \nSharing , but for now just remember that when we request a controller with \nrequire , \nwe're fetching the same instance that's in use on the \nng-switch  directive itself, and \nthus is shared with ng-switch  and all of the other ng-switch-[when\/default]  \ndirectives as well. Unlike ng-repeat , we're not going to use the linker  function immediately, but \ninstead we use the subordinate directives (when\/default) to collect all of the possible \nlinker  functions, and thus their respective DOM elements, and then store them \non the primary ng-switch  controller for use there. Once again, we use \n$watch  to \nconnect the data to our code, though in this case we're using the more common \nstring method. This time, instead of grabbing a specific data element to update our \nscope, we're grabbing the transclude function that's attached to a particular template, \nallowing us to update the element HTML automatically to reflect changes in the data.\n[ 36 ]\nWhat about linking?\nOk, so now that we've taken a look at some of the uses for compile, you may be \nwondering when you would ever want to use link. The answer: pretty much always. \nFirst of all, realize that both of the examples we reviewed in the preceding section \nuse the linking function; they just initialize it differently, then return it from the \ncompile function instead of attaching it directly to the \nlink property. Secondly, \nwhile the ability to have low level access to the \nelement template and fine-tune \nexactly when and where the linker  function comes into play sounds awesome (and \nit is), in reality there are actually very few times you'll need that much control. Out of \nthe 26 different directives included with the awesome AngularUI library, only three \nuse the compile property. And even those primarily use the compile function simply \nfor validating the directive options and prepping variables so they don't have to be \nrepeatedly looked up. Summary So, in the end, the compile function is awesome. It's also rarely needed. Most of the \ntime, your link function will handle all of the heavy lifting for you, and adding in \nthe compile option just creates unnecessary complexity within your code. On the \nother hand, when you need to be able to manipulate the template element before \nbinding to the scope, or want to conditionally apply the \nlinker  function as the  \ndata changes, compile offers you that option. Next chapter we'll dive into scoping, \n \na helpful way to ensure your data is properly linked, yet still modular, both inside \nand outside your directives.\nKeeping it Clean with Scope\n\"Why do we [scope], Master Wayne? So we can [stay modular and code like a \nrockstar]\" - Alfred (if he'd been an Angular developer)\nAs you've likely seen so far, the scope object\n within Angular serves as the primary \nintersection point between our data, our view, and the rest of our code. Any property \nor method that's available on our scope can be accessed and used within our HTML. \nLikewise, any changes that happen to the data will update the HTML and can trigger \nother updates within the rest of code, via the \n$watch  method  that we've already used \nseveral times. Those qualities of scope pervade nearly all of Angular development. Within a \ndirective however, scoping takes on an even more powerful role, allowing us to plug \ndirectly into the rest of the application scope, remain completely separate, or utilize \nsome blend of both. As a quick reminder about scoping when there are multiple directives \non an element, all directives receive the same scope, and whichever \ndirective requests the most limited scope gets priority. This means \nthat a scope of \"true\" trumps a scope of \"false\", and an isolate scope \n(object hash) trumps them all.\nNow, with whetted appetite, let's take a look at the three types of values we can use: \nfalse , true, and an object hash .\n[ 38 ]\nScope = false\nA scope property  value of false is the default for all directive definition objects. If \nyou've done much Angular development before, you might be tempted to assume that \nthis operates in the same manner as nesting another controller, where each directive \ngets a new inherited scope. With directives, however, that's actually not the case. When \na new directive is initialized with a scope property of false, that directive receives the \nsame scope as its parent. Not an inherited scope, but the exact same object. This means \nthat all changes to the parent scope will be reflected within our directive, and also any \nchange within our directive's scope will be reflected within the parent.\nTo help explain  the unique characteristics of this and the other types of \nscoping,  \ntake a look at the following HTML and directive declaration:\n<div ng-init=\"title = 'Hello World'\">\n  <h2 id=\"appTitle\">{{title}}<\/h2>\n  <button id=\"newAppTitle\" ng-click=\"setAppTitle('App 2.0')\">Upgrade \nme!<\/button>   <div my-scoped-directive>\n    <h4 id=\"directiveTitle\">{{title}}<\/h4>\n    <button id=\"newDirTitle\" ng-click=\"setDirectiveTitle('bob')\">Bob \nit!<\/button>   <\/div> <\/div> …directive('myScopedDirective', function() {\n  return {     scope : false, \/\/ we could leave this out, since it's the default\n    link : function ($scope, $element, $attrs) {\n      $scope.setDirectiveTitle = function (title) {\n        $scope.title = title;\n      };     }  };});\n[ 39 ]\nTo help visualize what happens here, let's diagram the effects of compilation and \nuser interaction on our $parentScope  and $directiveScope :\n$parentScope$directiveScopeng-init tag parsed{title :‘Hello World’ }my-scoped-directive initialized UnchangedsetApp Title fired{title : ‘App2.0’ }setDirectiveTitle fired{title :‘bob’ }\n{title :‘Hello World’ }\n{title : ‘App2.0’ } {title :‘bob’ }\nAs you can see, when Angular first parses through this HTML, it sees the \nng-init  \nattribute, which  it evaluates within the current scope before proceeding, and thus \nsets $scope.title  equal to Hello World . Then, when the element is fully compiled \nand linked, both #appTitle  and #directiveTitle  will say Hello World . We \ndevelopers are curious, however, which means that if there's a button, we must \nclick it. When we click the #newDirTitle  button, the setDirectiveTitle  method \ngets called and, working directly on our directive's scope, sets \n$scope.title to \nnow say bob. You might expect at this point #appTitle  to still read Hello World  \nand #directiveTitle  to bob. Remember however, that because we've set scope to \nfalse, the parent scope and the directive scope are in fact the same object, and thus \nboth #appTitle  and #directiveTitle  will now read bob.\nSometimes, this behavior is exactly what we want. Setting the scope to \nfalse  \ngives us unbridled interconnectivity with the parent scope and thus the rest of \nour application. Such power, however, comes with a price. As you can see in the \npreceding paragraph, it is exceptionally easy to accidentally change data in the rest \n \nof your application when using a non-scoped directive and so, unless you're sure \n \nyou need that much connectedness, my recommendation is to use a more limited \nscope whenever possible.\n[ 40 ]\nScope = true\nThe first step  down the path of limiting, or modularizing, your \nscope is setting its \nvalue to true. In this case, a new inherited scope is actually generated, much like the \nbehavior when nesting controllers. This type of scoping for a directive is by far the \neasiest to understand and operate within, as you still have read access to all of the \nparent scope's values, but it's less likely that you'll accidentally change the data in the \nrest of the application. For this reason, I usually recommend setting scope to \ntrue \nfrom the beginning, unless you have a strong reason to do otherwise.\nTo help clarify the difference of this type of scoping, let's revisit our previous \nexample. This time, the scope section of our definition object will be \nscope: true , \nbut otherwise all of the code will remain the same. When we first load the page, this \ndirective will be indistinguishable from our previously false-scoped directive; both \n#appTitle  and #directiveTitle  will still say Hello World  because our directive's \nscope is inherited from the parent.\nWe discussed this inheritance briefly earlier, but as a reminder, this is the prototypical \ninheritance innate to JavaScript. As such, any value not explicitly declared on our \nscope will be read from the parent, or parent's parent, all the way up to \n$rootScope . \nThe caveat, of course, is that setting, or writing, values does not work that same way. \nAs soon as we set a value, it's stored locally and we lose all connection to any ancestral \nproperty of the same name. Again, let's see how our directive will flow given our \nnewly updated scope parameter, as shown in the following figure:\n$parentScope$directiveScopeng-init tag parsed{title :‘Hello World’ }my-scoped-directive initialized UnchangedsetApp Title fired{title : ‘App2.0’ }setDirectiveTitle fired{title :‘bob’ }\n{title :‘Hello World’ }\n{title : ‘App2.0’ } {title : ‘App2.0’ }\nAs you can see, what this new scope object means for us is that once we click on our \nbutton and fire setDirectiveTitle , #directiveTitle  will change to bob, however \n#appTitle  will still say Hello World . This type of scoping has all of the advantages \nand disadvantages of prototypical inheritance. We get to keep read access to the rest \nof the application's data, and even the updates to it, as demonstrated by our firing of \nsetAppTitle , without having to worry about accidentally overwriting anything. On \nthe other hand, for values that you do want to change, it does require keeping track \nof which values are local and which are inherited, as well as using inherited methods \nto change any ancestral values.\n[ 41 ]\nScope = {} For times when you want to have complete control over which properties and \nmethods are interconnected within your new directive scope, an object hash is \nusually your best solution. This type of scoping is commonly referred to as an \nisolate scope , because of the lack of connectedness with the other scopes within the \napplication. An empty object signifies that you want the new scope to be completely \nisolated from its parents, so nothing is inherited or carried over. If absolutely \nnecessary, you can still access the parent or root scopes by using the \n$parent  and \n$root properties, respectively, however this goes directly against our goals of \nmodularity and thus should only be used when there's no better option.\nWhile there are a few instances where we want our directive to be entirely isolated, \nmore commonly we'll want to maintain access to a few explicitly specified properties \nand methods from the ancestral scope tree. To do this, Angular provides three \nsymbols for notating what type of access you want to acquire: \n@, =, and &, which are \nprepended to the attribute names that you want to derive a value from. As such, we \ncan create an isolate scope that looks like this:\nscope : {   'myReadonlyVariable' : '@myStringAttr',\n  'myTwowayVariable' : '=myParentProperty',\n  'myInternalFunction' : '&myParentFunction'\n}@ – read-only Access\nUsing the @ symbol to retrieve a value from your attributes means that the \nattribute \nvalue will be interpolated and whatever is returned will be stored within the scope \nproperty that you specify. To help explain, let's expand our previous scoping \nexample with a few extra details as shown in the following code snippet:\n<div ng-init=\"title = 'Hello World'\">\n  <h2 id=\"appTitle\">{{title}}<\/h2>\n  <button id=\"newAppTitle\" ng-click=\"setAppTitle('App 2.0')\">Upgrade \nme!<\/button>   <div my-scoped-directive msd-title=\"I'm a directive, within the app \n{{title}}\">     <h4 id=\"directiveTitle\">{{title}}<\/h4>\n    <button id=\"newDirTitle\" ng-click=\"setDirectiveTitle('bob')\">Bob \nit!<\/button>   <\/div> <\/div> …\n[ 42 ]\ndirective('myScopedDirective', function() {\n  return {     scope : {       'title' : '@msdTitle'\n    },     link : function ($scope, $element, $attrs) {\n      $scope.setDirectiveTitle = function (title) {\n        $scope.title = title;\n      };     }  };});First, as a  quick reminder, within our JavaScript, all attribute names \nare normalized \nto be camelCased, which is why we refer to the HTML attribute \nmsd-title  as \nmsdTitle  within our scoping object. Secondly, take note of how our attribute string \nis evaluated. The {{title}}  value in our attribute will be evaluated within the \nparent scope, not in the new internal scope we're creating. Thus, in this example, \n#appTitle  will still be Hello World , but #directiveTitle  will now read I'm a \ndirective, within the app Hello World .\nThirdly, it is important to realize that even though we've requested only read-only \naccess for this attribute, it will still be dynamically updated when the parent scope \nchanges. If a user clicks on our \n#setAppTitle  button, the #appTitle  will be updated \nto App 2.0  and #directiveTitle  will mirror that change by now reading \nI'm a \ndirective, within the app App 2.0 . Of course, as you can probably ascertain by the \"read-only\" nature of this access, \n \nthe reverse is not true. If our user now clicks on our \n#setDirTitle  button, #appTitle  \nwill remain unchanged, #directiveTitle  will now read bob, and, most importantly, \nwe've now severed the connection between the two values. The following figure \nprovides insight into the state of our data at each point of the process:\n$parentScope$directiveScopeng-init tag parsed my-scoped-directive initialized Unchanged\n{title :‘Hello World’ }\nsetApp Title fired {title : ‘App2.0’ } {title :‘bob’ }setDirectiveTitle fired {title : ‘App2.0’ }\n{title :‘I'm a directive, within theappHello World’ } {title :‘I'm a directive, within theappApp2.0’ }\n[ 43 ]\nFrom this  point forward, any updates to the parent scope's title \nproperty will be \nignored by our directive, as we've overridden our original linked value with a new \nstatic value. If we you need both read and write access to a property, you will need \nto instead utilize the following method for requesting property access.\n= – two-way binding\nFor occasions where you want full access to a specific property on the parent \nscope, \nAngular provides the = symbol for use within our isolate scope. Let's extend our \noriginal example again to see how this can be useful:\n<div ng-init=\"title = 'Hello World'; subtitle = 'I am an app'\">\n  <h2 id=\"appTitle\">{{title}}<\/h2>\n  <h3 id=\"appSub\">{{subtitle}}<\/h3>\n  <button id=\"newAppTitle\" ng-click=\"setAppTitle('App 2.0')\">Upgrade \nme!<\/button>   <div my-scoped-directive msd-title=\"I'm a directive, within the app \n{{title}}\" msd-subtitle=\"subtitle\">\n    <h4 id=\"directiveTitle\">{{title}}<\/h4>\n    <button id=\"newDirTitle\" ng-click=\"setDirectiveTitle('bob')\">Bob \nit!<\/button>     <button id=\"newDirSub\" ng-click=\"setDirectiveSubtitle('Time to \nsubmerge')\">Empty the ballasts!<\/button>\n  <\/div> <\/div> directive('myScopedDirective', function() {\n  return {     scope : {       'title' : '@msdTitle',\n      'subtitle' : '=msdSubtitle'\n    },     link : function ($scope, $element, $attrs) {\n      $scope.setDirectiveTitle = function (title) {\n        $scope.title = title;\n      };       $scope.setDirectiveSubtitle = function (subtitle) {\n        $scope.subtitle = subtitle;\n      };     }  };});\n[ 44 ]\nNow that's we've  updated our code, the data model now proceeds \nthrough the \nfollowing flow:$parentScope$directiveScopeng-init tag parsed my-scoped-directive initialized setDirectiveSubtitle fired\n{title :‘Hello World’, subtitle : ‘I am anapp’ } Unchanged{title :‘I’m a directive, within theappHello World’, subtitle : ‘I am anapp’ }{title :‘Hello World’, subtitle :‘Time tosubmerge’ }{title :‘I’m a directive, within theappHello World’, subtitle :‘Time tosubmerge’ }\nWithin this scenario, our subtitle  property works in exactly the same \nway as it would if we had set the entire scope property to \nfalse. When our \napp is first initialized, both subtitles will read \nI am an app . If we fire the \nsetDirectiveSubtitle  method, however, both values will again change, this time \nreading Time to submerge . Given that this method of binding is identical to a false \nscope property, we might be inclined to wonder why this option is even provided. \nThe difference here is that we only have this two-way binding for properties that \nwe explicitly specify, which helps us ensure modularity. Because of the way we've \nbound our property, we don't care about the name of our parent property. It could \nbe lesser-title-the-third  for all we care, and as long as that property is passed \ninto our msd-subtitle  attribute, our directive will continue to function in exactly the \nsame way, including updating the parent scope's property when our button is clicked. \nAnd, of course, the reverse is also true. When developing our parent application, \n \nwe don't need to worry about our property names conflicting with those used in \n \nour directive and suddenly being overwritten. This type of binding plays a huge \n \nrole in making sure a directive  can be plugged into any application and have both \n \nthe directive and the application function as their respective developers intended.\n& – method binding\nSometimes, however, it's not  simply properties that you want to be able to maintain \naccess to. Sometimes you need to be able to call a method on the\n parent scope. For \nthis, the symbol of choice is &, and let's once again return to our example to see how \nthis symbol is used, as shown in the following code snippet:\n<div ng-init=\"title = 'Hello World'; subtitle = 'I am an app'\">\n  <h2 id=\"appTitle\">{{title}}<\/h2>\n  <h3 id=\"appSubtitle\">{{subtitle}}<\/h3>\n[ 45 ]\n  <button id=\"upgradeApp\" ng-click=\"setAppTitle('App 2.0', 'Still an \napp')\">Upgrade me!<\/button>\n  <div my-scoped-directive msd-update-title=\"setAppTitle(title, \n'Updated by a directive')\">\n    <h4 id=\"directiveTitle\">{{title}}<\/h4>\n    <button id=\"bobApp\" ng-click=\"updateTitle({title : 'bob'})\">Bob \nit!<\/button>   <\/div> <\/div> \/\/Parent scope: $scope.setAppTitle = function (title, subtitle) {\n  $scope.title = title;\n  $scope.subtitle = subtitle;\n}…directive('myScopedDirective', function() {\n  return {     scope : {       'updateTitle' : '&msdUpdateTitle'\n    },     link : function ($scope, $element, $attrs) {\n      $scope.title = 'Lonely Directive';\n    }  };});Method binding is by far the most complicated of all scope bindings, so don't worry \nif it doesn't all make sense instantly. In most cases if you need to share methods \nbetween parent and child directives, I'd recommend using controllers (see our next \nchapter) whenever possible, however this is helpful if for some reason your method \nhas to be scoped. Once more, the following diagram demonstrates the flow of the \ndata model as our user interacts with our elements:\n$parentScope$directiveScopeng-init tag parsed {title :‘Hello world’, subtitle : ‘I am anapp’ }my-scoped-directive initialized Uncharged{title :‘Lonely Directive” }\nsetAppTitle fired {title : ‘App2.0’, subtitle :‘Still anapp’ }{title :‘Lonely Directive’ }\nupdateTitle fired {title :‘bob’, subtitle :‘Updated by adirective’ }{title :‘Lonely Directive’ }\n[ 46 ]\nIn this example, we've extended our parent scope's \nsetAppTitle  method to take two \narguments, allowing us to update both the title and subtitle at the same time. We've \nalso requested access to that same function and passed it in via the \nmsd-update-title  \nattribute. Note, however, that we don't just ask for it by name. Instead, the attribute \nvalue actually calls the function with a set of variable and\/or hard-coded parameters. \nThen, within our new scope, Angular creates a wrapper function that takes a map of \nthe variable names and values (the \n{title : 'bob'}  parameter in our example) and \ncalls our original method within the context of the parent scope, passing in all mapped \nvalues and other hard-coded parameters.\nWhat this means is that when we first click on the \n#upgradeApp  button, our \n#appTitle  will become App 2.0  and our  #appSubtitle will read Still an app . \nIf, however, we click on the #bobApp  button within our directive, our wrapper \nfunction, bound to updateTitle  within our directive's scope will be called, the \ntitle variable within our msd-update-title  value will be mapped to bob, and \nfinally setAppTitle('bob','Updated by a directive')  will be called within the \nparent scope. It's important to emphasize that the entire function is called within the \nparent scope, so even though we're passing in a title value and calling it from the \ndirective, it's the parent scope's title property that we're actually updating.\nAgain, binding a method like this is one of the most complex binding options \nAngular offers for use in an isolate scope, however it also allows you as the \ndeveloper once again to remain fully modular, having to worry about the internal \nlogic within the setAppTitle  method, or even what it's called, and yet still be able \nto trigger it as you see fit. This type of access can be especially helpful when you \nwant to be able to trigger a data refresh from an external source, but don't want \nyour directive to know anything about how to go about that refresh \nor any data \nprocessing that needs to happen before or after the new content is received.\n[ 47 ]\nSummary If you've made it this far, I trust you're convinced of the value of modularity and \nare interested in the ways Angular directives can make that easier for you. Scoping, \nparticularly isolate scopes, is one of the most fundamental pieces of enabling that \nmodularity. While the default scope value of \nfalse  can certainly be convenient, and \nis often useful during early development and debugging, I strongly recommend not \nusing it within your final production code unless you know it's absolutely necessary, \nand certainly not when you're developing a directive intended to be packaged and \nmade available for use in other applications. The new scope provided by a value of \ntrue does provide a helpful compromise, though is still often more access than you \nneed for a packaged directive. Hopefully by now, you see the value of an \nisolate \nscope , even though it does require some additional effort up front to consider all \nof the properties and methods you might need. If not, hold on, it'll demonstrate its \nusefulness even more in the coming chapters. In the next chapter, we'll be talking \nabout controllers, and the ways they can be shared across multiple directives to \nextend the functionality of each.\n\nControllers – Better  with Sharing\nIn Chapter 4 , Compile versus Link , we walked through the compile and link steps of \nthe Angular compilation process. What we set aside, at that point, were controllers, \nwhich are also functions that execute as Angular applies a directive. In and of \nthemselves, controllers don't provide significant advantages over local methods \nwithin the linking function of your directives. When paired with their ability to be \nshared across directives, however, controllers provide unparalleled communication \nbetween directives on the same node, or even just within the same ancestral tree. \n \nTo get a better understanding of how these controllers can enable directives to work \ntogether, let's take a look at the \nngModel  and form controllers, which combine to \nprovide much of the real-time data binding that powers Angular's dynamic content.\nForms and inputs\nWithin Angular, every form element  is also a directive whose primary purpose \n \nis to instantiate a  FormController  object, attach it to the form element and, if the \nform is named, register that form controller on the parent scope so that it can be \nmore easily accessed. Likewise, all input and input-esque elements (for purposes \nof this discussion, we'll include the \nselect  and textarea  tags within the input \nelements category) are also built-in directives, although unless they have an \n \nng-model  attribute on them, they don't actually have any extra functionality.\n[ 50 ]\nOur HTML for this example is pretty simple, just a simple\n form with a single  \ninput element. <form name=\"exampleForm\">\n  <input type=\"text\" ng-model=\"myName\" \/>\n<\/form> The FormController  function is primarily responsible for monitoring the overall \nvalidity of the form, based upon the validity of the individual elements within it. \n \nIt does this through the use of the four main functions within the controller function \noutlined as shown: function FormController(element, attrs) {\n  \/\/All controller functions and properties you want to export are \nbound to 'this'   this.$addControl = function(control) { ...}; \/\/Register an input \nelement   this.$removeControl = function(control) { ...}; \/\/Unregister an \nelement   this.$setValidity = function(validationToken,  \n    isValid, control) { ...}; \/\/Set the validity for a specific \nelement   this.$setDirty = function() {...}; \/\/Mark the form as having been \nmodified }For the purposes of this discussion, we're not going to worry about the internal \n \nlogic of the FormController  functions, what instead I want you to note is \n \nthat, on its own, this controller does absolutely nothing. It's a handy collection \n \nof functions, but without any input elements, a form is simply sitting there, \n \n\"valid\", but otherwise unimpressive.\nYou've (hopefully) read the introductory paragraph, however, so you already \nknew that, and are now sitting there patiently waiting for the big reveal where \nngModelController  arises with a flourish and shows you just how cool controllers \nreally are. Well, far be it from me to fool you twice (yes, I know after the whole \nselect  directive and compile twist, you might be cautious), so let's dive straight \n \ninto the ngModelController  function:\nNgModelController = function($scope, $exceptionHandler, $attr, \n$element, $parse) {    this.$render = noop;\n  var parentForm = $element.inheritedData('$formController') || \nnullFormCtrl ;\nChapter 6\n  this.$setValidity = function(validationErrorKey, isValid) {\n    … \/\/Internal processing\n    parentForm.$setValidity(validationErrorKey, isValid, this);\n  };  this.$setViewValue = function(value) { ... };\n};And then finally, tying it all together is the\n ng-model  directive, which grabs both \ncontrollers and teaches them to share:\nngModelDirective = function() {\n  return {     require: ['ngModel', '^form'],\n    controller: NgModelController,\n    link: function(scope, element, attr, ctrls) {\n      var modelCtrl = ctrls[0], \/\/grab the instance of the ngModel \ncontroller           formCtrl = ctrls[1]\n      formCtrl.$addControl(modelCtrl);\n      element.bind('$destroy', function() {\n        formCtrl.$removeControl(modelCtrl);\n      });     }  };};So yes, I admit, that  was a lot of code. Feel free to go walk around the block to let \nit all settle in your mind before continuing... Ok, cool, let's dive in then. Part of the \nreason there's so much code is that that's what makes controllers powerful, they \nprovide the ability to tie together large amounts of otherwise disconnected code into \na cohesive package. In this example, you can see that when the \nng-model  directive \ninitializes, it requests an array of controllers, both its own and the \nFormController , \nthe latter of which is both optional and can be located on ancestral elements.\nLet's go ahead and walk through the code to see how that all comes together. \nRemember that the compilation process proceeds down the DOM tree, so the \nFormController  function initializes first. After the form is compiled, Angular \n \nworks its way down to our input element, where it initializes the\n \nngModelController  function: NgModelController = function($scope, $exceptionHandler, $attr, \n$element, $parse) {   this.$render = noop; \/\/Each directive that requires ngModel must \nimplement this method to properly display the value\n[ 52 ]\n  \/\/ Grab the form controller if there is one\n  var parentForm = $element.inheritedData('$formController') || \nnullFormCtrl ;   this.$setValidity = function(validationErrorKey, isValid) {\n    … \/\/Internal processing\n    parentForm.$setValidity(validationErrorKey, isValid, this);\n  };  this.$setViewValue = function(value) { ... };\n};Before we continue, there are a couple of things to note here. First, unlike the link \nand compile functions, you can pass in any available service or dependency, such \nas $exceptionHandler  and $parse  in the preceding example. Additionally, we can \ngrab the FormController  function off the element data ( $element.inheritedData(\n'$formController') ), which we can then use to pass validity information as part of \neach input's own $setValidity  method. This connecting of controllers to elements \nall happens via the directive, and is our first example of using directive controllers to \ncoordinate across elements.\nOnce the ngModelController  function is  initialized, Angular continues with the \ncompilation process and triggers the linking function on the element itself, as shown \nin the following code:\nngModelDirective = function() {\n  return {     require: ['ngModel', '^form'],\n\/\/request an array of controllers. Look for formController on parent \nelements     controller: NgModelController,\n    link: function(scope, element, attr, ctrls) {\n      var modelCtrl = ctrls[0],\n\/\/grab the instance of the ngModel controller\n          formCtrl = ctrls[1];\n\/\/grab the form controller\n      formCtrl.$addControl(modelCtrl);\n\/\/register our ngModel controller\n      element.bind('$destroy', function() {\n        formCtrl.$removeControl(modelCtrl);\n\/\/unregister our controller if this element is removed\n      });     }  };};\nChapter 6\nAs a reminder, the require  property can be a string if we only want one controller, \nor an array as we have here. With the array format, the \nctrls parameter passed \ninto our linking function is also an array, in the same order as we requested them. \nHere, we've grabbed both controllers, and thus are able to call the \nFormController 's \naddControl  method and pass in our ngModelController  function. From this point \nforward, each controller, and therefore each directive, is fully aware of the relevant \nchanges happening on the other.\nAt this point, you may be asking why we're not simply using basic messaging with \n$broadcast  and $emit to communicate between our directives. There are two basic \nreasons why we prefer controllers over messaging\n in this scenario:\n• First, idealistically, using controllers is significantly more modular. It allows \nus to separate out instance code that needs to be shared and available for \ncross-directive communication from the rest of the scope, while still keeping \nsuch methods available for convenient usage.\n• Secondly, more pragmatically, controllers are far easier to utilize for \nscenarios like this. Messaging is designed primarily for a shotgun notification \napproach, such that when an event happens, you broadcast it to all of \nthe elements above or below your current node, and then continue on. \nControllers, however, allow for a much more targeted communication style, \ncalling methods on specific nodes as necessary, and while we didn't use \nthem here, also allowing for easy callback integration. Doing the same sort of \ntargeted communication via messaging requires significant extra logic on the \npart of the listeners to determine whether or not they're the intended node.\nThere are certainly still plenty of times where the more open broadcast style of \nmessaging suits your goals better. Controllers simply fill in when a more targeted \napproach is preferred. Creating our own controller \ncommunication\nMost likely, you'll find  that ngModel  is the most common controller you'll require \nwithin your code. Any time you want to create a custom input, or even just bind an \ninput plugin that requires specific formatting, \nngModel  provides the methods you'll \nneed to coordinate communication between the plugin and your data model.\n[ 54 ]\nWith that in mind, let's walk through the process of creating an input for time values \nthat utilizes the handy timepicker jQuery plugin provided by Jon Thornton. Our goal \nis to be able to turn a regular text field input into a timepicker that displays its value \nin the format HH:mm but stores it in our data property in milliseconds.\nFor this example, our HTML is once again pretty simple, as shown here:\n<input type=\"text\" ng-model=\"timeOfDay\" time-picker \/>\nObviously, we'll also need to include the timepicker plugin within our main page \nso that it can be attached to our input, so if you're recreating the code on your own, \nbe sure to do that before continuing on. For our directive, let's start with the basic \ndefinition object, and since we know we need data-binding functionality, we'll \nrequire ngModel  from the start so that we can utilize its methods.\n.directive('timePicker', function () {\n  var today = new Date(new Date().toDateString());\n  return {     require : '?ngModel',\n    link : function ($scope, $element, $attrs, ngModel) {\n    }  }});Note that since we need to be working with the actual instance of the element, \nalmost all our code is going to sit inside the linking function, and we don't need to \nworry about the compilation process at all. We've also initialized a \ntoday variable \nthat holds a Date object set to this morning at midnight. Creating the variable as part \nof the factory function allows us to just have one \ntoday variable that's shared across \nall instances of our time-picker  directive. Be careful, however, as even though \nthis allows us to minimize memory usage, it does mean that if our app is left open \novernight, our directive will start providing inaccurate results. If you're planning \n \non using this directive in a live application you'll want to create a secondary function \nthat updates this value once tomorrow comes. Let's move forward now and grab \n \nour controller: link : function ($scope, $element, $attrs, ngModel) {\n  ngModel = ngModel || {\n    \"$setViewValue\" : angular.noop\n  }}\nChapter 6\nYou may have noticed this pattern before, as a part of the \nform and ngModel  \ncontrollers that we looked at previously. Remember that we've made our controller \nrequirement optional, so that if someone wants to use our directive just to attach \na timepicker, but doesn't need the data-binding offered by \nngModel , our directive \nwon't throw an error when it doesn't find the requested controller. We could just \nuse conditional statements to verify that \nngModel  is defined each time we need \nto use it, however the developers at Angular use this pattern, and I recommend \nit, in order to help keep the directive code a little cleaner. All we're doing here is \nsaying that if ngModel  is defined and has a true value, use that. If not, define it as \nan object with all of the requisite method names set to a no-op function (\nangular.\nnoop is a convenience method provided for exactly this purpose). Now when we \ncall ngModel.$setViewValue  later in our directive, if there's no \nngModel  directive \nattached to our node, our code will continue along without an issue.\nSpeaking of ngModel.$setViewValue , let's take a look at how we'll attach our \ntimepicker and where we might need that very function. If you've been pining \n \naway for a jQuery plugin while reading this book, now is the time for a brief \n \nmoment of relief: link : function ($scope, $element, $attrs, ngModel) {\n  …  var initialized = false;\n  setTimeout(function () {\n    initialized = $element.timepicker()\n      .on('changeTime', function (ev, ui) {\n        var sec = $element.timepicker('getSecondsFromMidnight')\n        ngModel.$setViewValue(sec * 1000);\n      });   });}Undoubtedly, your first question is going to be about \nsetTimeout , particularly one \nwith no actual timeout. Because we're in the linking function, our \n$element  is fully \ninstantiated, so this sort of trickery shouldn't be necessary. And you're right, it isn't \nnecessary. It is, however, a practice I recommend, for two primary reasons. First, \non occasion, particularly if your directive or another on your element is applying a \ntemplate, Angular and jQuery will both try to apply themselves at the same time and \nyou run into a race condition. While this is rare, and usually means that your plugin \nisn't actually working on the $element  itself, but trying to clone it or nest something \ninside, it still can cause a few headaches and this helps guard against that.\n[ 56 ]\nSecondly, and more importantly, is that when you begin to develop larger \napplications and have hundreds or even thousands of different directive instances \nall manipulating and binding to their own elements in various ways, any plugin \nthat requires DOM manipulation tends to slow things down. And often, especially \nfor input type plugins that are hidden until the user directly interacts with them, \nthese plugins can wait a few milliseconds to initialize themselves without harming \nthe user experience. Wrapping our initialization process within \nsetTimeout tells \nthe JavaScript interpreter to process this after it's done with the current task, so the \ncompilation process doesn't get delayed by our jQuery plugin attachment. Again, \nthis isn't a necessity, but it is a practice I recommend you consider as you begin to \ndevelop larger applications with Angular.\nNow that we've discussed that, let's take a look at how we're using \n$setViewValue . \nBecause we've grabbed a shared instance of our \nngModel  controller, we can call the \ncontroller's $setViewValue  function from our own directive, which helps us connect \nour plugin to the data model. Remember that this is used to take the display value, \nperform any necessary parsing, and then store it in the data property. The timepicker \nplugin emits a changeTime  event anytime the user updates the time value displayed \nin our input, so we use that to know when we need to change our internal value. \nWithin our event handler, all we have to do is get the number of seconds since \nmidnight, which the plugin provides a convenience method for, then multiply it by \na thousand and pass that into $setViewValue . Once we're done, our data will travel \nthrough the following process:The ngModel controller\ntakes in the new value\nand updates the data model appropriately\nOur event listener grabs\nthe seconds from midnight,\nmultiples by 1000, and\npasses to $setViewV alue\nUser selects a value, timepicker fires ‘changeTime’ eventOnce we have our timepicker initialized and listening for changes in the view, our \nnext step is to define the $render  method, which is responsible for converting a data \nvalue to the appropriate display or view value. This will be called any time the data \nvalue changes from a source outside our directive, including when it's first initialized \nand can be defined as follows:\nlink : function ($scope, $element, $attrs, ngModel) {\n  …  ngModel.$render = function (val) {\n    if (!initialized) {\nChapter 6\n      \/\/If $render gets called before our timepicker plugin is ready, \njust return       return;     };     $element.timepicker('setTime', new Date(today.getTime() + val));\n  }}Again, note that we're actually redefining the $render  method of our shared \nngModelController  function, so when the ngModel  directive observes a data change \nand tells the controller to execute \n$render , it's our function that gets called. All we \nhave to do is know how to transform the data-model value into a value our plugin \nexpects. In this case, the timepicker plugin provides a method for setting the time \ndisplayed by passing in a Date object with the specified time. Because our values are \nstored in milliseconds since midnight, when we need to render a value, we simply \ntake the time from today, add on our new value, and create a \nDate object with that \nvalue. Again, when we're finished, our data will flow back into the view via the\n \nfollowing process:Timepicker updates element and displays 2:58PM Our $render function adds val to today’s time\nand passes it to ‘setTime’\nngModel Directive observes change and calls $render with val = 53907764Summary As you have hopefully seen, controllers provide a powerful mechanism for connecting \ntwo or more otherwise disconnected directives. This means that each directive can \nprovide its own functionality, such as the simple timepicker plugin, but also extend \nits functionality if another directive is present. This targeted communication helps us \nmake calls and interact with other pieces of an application directly without the need \nfor the general broadcast approach provided by messaging. For the next chapter, we \nare moving on to a different topic entirely, transclusion, which allows you to utilize \n \nthe existing content of an element when applying your directive.\n\nTransclusion\nUp to this point, we've primarily focused on one side of directives, which is how \nthey can affect the elements to which they are attached by replacing the HTML via \na template, binding additional plugins, or some combination of the two. In this \nchapter, we're going to look at the opposite side and see how transclusion\n allows \nfor the original element's content to impact the behavior of the directive. While this \nmethodology is certainly less common, it still is a powerful tool to be aware of and \none you should call to mind when you find yourself tempted to create multiple \ndirectives that only vary from one another in content. With that, let's dive in and \ncheck out some examples. That's not a word...\nTrue. Looking up transclude  in the dictionary won't help you understand what's \nreally happening here (a fact lamented in the comment section on Angular's \ndocumentation site). I believe, however, that a brief dive into why they created this \nword in the first place will actually help greatly in your understanding of what its \nreal purpose is, so bear with me a moment while we step aside from the focused \nrealm of JavaScript and breathe deeply in the wider world of computer science.\nIf you've ever had the privilege, or arduous task, of creating a templating syntax, \nalong with the parser required to bring that syntax to life, you're likely familiar \n \nwith the concept of inclusion. Within a template, various snippets of code will \noften be repeated. In HTML, this is commonly seen with headers, footers, a Twitter \nwidget, and so forth. And in the continuous quest for\n Don't-Repeat-Yourself  code,  \nwe usually build 'include' commands into our templating definitions that allow you \nto write your snippet of code once and then drop it into other parts of your template \nwherever you want.\n[ 60 ]\nThat part of templating, pretty much everyone agrees upon. There remains a \nquestion, however, which is: if you're including a snippet that itself has dynamic \nvariables and needs to be parsed, what scope do you use when parsing it? Some \nwidgets, such as the Twitter widget mentioned in the preceding paragraph, benefit \nfrom being parsed all by themselves in an isolated scope, and then just having the \ncompiled result inserted at the include tag. Other widgets, such as a customized \nblog post header or dynamic list display, however, need to be parsed within the \noriginal scope of the include tag, not outside of it. Most mature templating syntaxes \nhave ways of performing both types of inclusion, but it's a problem that each syntax \ndesigner must answer in their own way. ...it is a solution\nFor Angular that answer is transclusion. My unofficial interpretation of the word is \ntranslated-inclusion . What transclusion does is offer a way to create a widget with an \nisolate scope, which we as good modular developers always do, but then tunnel back \nout into the parent scope to parse the original content. This, of course, is significantly \nclearer in an example, so let's check one out. Take a look at the following HTML and \nnote what's different from our previous examples:\n<div>   <input type=\"text\" ng-model=\"name\" \/>\n  <select ng-model=\"movie\">\n    <option value=\"Man Of Steel\">Superman<\/option>\n    <option value=\"A New Hope\">Star Wars<\/option>\n  <\/select>   <input type=\"number\" ng-model=\"friendCount\" \/>\n<\/div> <div movie-info=\"movie\">\n  <p>Hi, I'm {{name}}, and I'm going to see {{movie}} with \n{{friendCount}} friends<\/p>\n<\/div>Ok, so what do you notice? Hopefully, one of the main things you saw is that our \ndirective, movie-info , isn't just an empty node this time. It has child nodes. Before \nwe get too much farther into how exactly that impacts our development, however, \nlet's take a look at the directive definition as well:\ndirective('movieInfo', function () {\n  return {     template : '<div class=\"movie-info\">' +\n      '<h1 class=\"movie-title\">{{name}}<\/h1>' +\n      '<img class=\"movie-poster\" ng-src=\"posters\/{{name}}.jpg\" \/>' +\n      '<div ng-transclude><\/div>' +\n    '<\/div>',\n[ 61 ]\n    transclude : true,\n    scope : {       'name' : '=movieInfo'\n    }   }});Now I should ask again, what do you notice? Perhaps most notably, we have a \nscoping issue. On the one hand, we're adhering to our principle of modularity and \nisolating our scope. On the other hand, however, we've ignorantly introduced a \nnaming conflict. Both scopes use the \nname property, and even though our scope \nis isolated, the origin element content we've pulled in is now inside our directive \nelement, so surely it's going to be parsed against the directive scope, which isn't the \nname property we want. Enter transclusion, stage left. Remember, we said that transclusion stands for \ntranslated-inclusion, which means that first we parse it and then we include it. In \nthe official Angular documentation, they explain this by saying that the transcluded \nscope and the isolate scope are siblings. The transcluded scope inherits from the \nparent scope per normal, and the isolate scope, though still a child of the parent \nscope, is otherwise disconnected.\nThat undoubtedly sounds fascinating, but perhaps a bit obtuse. Let's take a look \nthen, at what our HTML will look like after everything is parsed and compiled, \ntaking note of the highlighted values:\n<div>   <input type=\"text\" ng-model=\"name\" \/><!-- value: \"Alex\" -->\n  <select ng-model=\"movie\">\n    <option value=\"Superman\">Man of Steel<\/option><!-- selected -->\n    <option value=\"Star Wars\">A New Hope<\/option>\n  <\/select>   <input type=\"number\" ng-model=\"friendCount\" \/><!-- value: 3 -->\n<\/div> <div movie-info=\"movie\">\n    <div class=\"movie-info\">\n      <!-- these two lines parse against the directive scope -->\n      <h1 class=\"movie-title\">Superman<\/h1>\n      <img class=\"movie-poster\" src=\"posters\/Superman.jpg\" \/>\n      <div ng-transclude>\n        <!-- Everything in here parses against the parent scope -->\n        <p>Hi, I'm Alex, and I'm going to see Superman with 3 \nfriends<\/p>       <\/div>     <\/div> <\/div>\n[ 62 ]\nAs this hopefully makes clearer, we've effectively created a tunnel to the parent \nscope, hidden from the directive's scope and yet fully accessible to the transcluded \nportion nested inside. And, of course, all these data values are dynamic, so if the \nuser selects a different movie, all the instances of \nSuperman  will change to Star \nWars, whether they're bound to the movie property of the parent scope or the \nname \nproperty of the directive scope. Likewise, changing the parent scope's \nname property \nwill only affect the value within our transcluded element, the directive scope will \nremain ignorant of its existence entirely.\nManipulating the transcluded content\nSometimes you want more control  over the transcluded content than just dropping it \ninto an element and calling it a day. There are a couple of different methods you can \nuse, but I've found the most efficient and straightforward is by utilizing the directive \ncontroller. As you likely remember from the previous chapter, one of the main \nbenefits of controllers is that they can be shared across directives. Another feature, \nnot as commonly used, is that they can also require \n$transclude , which provides a \ntransclusion function already properly bound to the parent scope and ready for use.\nAgain, you'll really only need to utilize this functionality when you want to \nmanipulate the transcluded content before including it in your new directive \nelement, otherwise the standard procedure we used in the preceding section is far \nsimpler and easier to debug. That said, let's take a look at a situation where this can \ncome in handy. Consider that you have a blog header that you want to enhance. \nYour starting HTML might look like the following:\n<div class=\"post\">   <h2 class=\"post-header\">\n    <span class=\"title\">{{postTitle}}<\/span> |\n    <span class=\"author\">{{author}}<\/span>\n    <span class=\"date\">{{formattedDate}}<\/span>\n  <\/h2>   <div class=\"content\">...<\/div>\n<\/div>While that conveys all the necessary information, it's rather boring. Suppose you \nwant to only show the title normally, then when your devoted reader scrolls down \nto a specific post, the title slides to the center and your author and date values fade \nin on the sides (If you're a designer, apologies for my admittedly developer-brained \ninvention here). While you could try using a series of regular jQuery plugins for this, \nhopefully by this point in our book you've become so awed by the structure that \nAngular provides for modularity that your days of non-data-driven plugin-binding \nare a thing of the past. If not, humor me for the sake of our example.\n[ 63 ]\nSo, you want this awesome blog post header and you've got the plugins ready for \ndetecting scroll positions and fading in your metadata; the only trick is that they \n \nall work much better together if your HTML actually looks like this:\n<div class=\"post\">   <div class=\"post-header\">\n    <span class=\"date\" style=\"display:none;\">{{formattedDate}}<\/span>\n    <h2 class=\"title\">{{postTitle}}<\/h2>\n    <span class=\"author\" style=\"display:none;\">{{author}}<\/span>\n  <\/div>   <div class=\"content\">...<\/div>\n<\/div>With the power of controller fueled transclusion, we can do just that. Remember, \nwhen we request $transclude , it's already bound correctly, so even if we have other \ndirective scope properties in here, they won't conflict with our post values. And \nfor those of you craving a bit of jQuery based DOM manipulation, this next slice of \nexample code is my gift to you:\n.directive('postHeader', function () {\n  var tpl = '<div class=\"post-header\"><\/div>';\n  return {     template : tpl,     replace : true,     restrict : 'C',\/\/We're attaching ourselves to the classname 'post-\nheader' here     transclude : 'element',\/\/We want the whole element, not just the \ncontent     controller : function ($scope, $element, $attrs, \n$transclude ) {\n      $transclude(function (clone) {\n        \/\/clone is our transcluded element, in this case the h2 tag, \nfully compiled and ready for use\n        clone.removeClass('post-header');\/\/ this class is on our main \ndirective element now\n        var title = clone.find('.title').text();\n        var dateEl = clone.find('.date').hide();\/\/Start hidden\n        var authorEl = clone.find('.author').hide();\n        \/\/ Now insert them all in where we want them\n        $element           .append(dateEl)\n          .append('<h2 class=\"title\">'+title + '<\/h2>')\n          .append(authorEl);\n      });       \/\/When a user scrolls down to our element, reveal author and \ndate\n[ 64 ]\n      $element.waypoint(function () {\n        $element.find('.date, .author').fadeIn();\n      });     }  }});Summary As you can see, once we've grabbed $transclude , the rest of the manipulations \nare actually quite standard. In this case, because we've distributed the transcluded \ncontent in a piecemeal manner, we end up not even ever inserting the \nclone \nelement itself back into the DOM; however there might be other times when you \nonly want to extract part of the element for use elsewhere, and then insert the rest \nback into its normal location. In either case, always remember that transclusion is \nyour friend when you need to interact with the content internal to your directive. \nUse the standard ng-transclude  directive when you want the content unaltered, \nand controller  plus $transclude  if you need to manipulate it first. Coming up \nnext we're going to spend two chapters talking about testing, both unit testing and \nAngular's scenario end-to-end testing framework.\nGood Karma – Testing  in AngularJS\nAh, testing! The process that every young developer believes they don't need; of \ncourse, every experienced developer just looks at them and says, \"Just wait, you'll \nsee.\" Often, however, experienced or not, testing is one of the last tasks we as \ndevelopers think about, if for no other reason than because it tends to feel like a \nwhole new development task, and even worse, one where perhaps your client or \nboss thinks you're wasting time because they can't see the direct results. In an effort \nto help assuage this suffering, Angular\n comes shipped with Karma, a test runner \nbuilt to make testing easier and designed to make testing as easy as just scoping \n \nout the desired functionality, and instead of being a part of the process that drags \ndown your morale, it gives you immediate feedback on the effectiveness, or \n \nnot-quite-there-yet-ness, of your code, which quickly makes for faster and more \nefficient development overall. Getting Started\nNow that we have the obligatory testing-is-good platitudes out the way, let's dive \ninto Karma and let it prove its worth on its own. If you already have \nNPM (Node \nPackage Manager ) installed, installing Karma is as simple as \nnpm install -g \nkarma. If not, head over to http:\/\/karma-runner.github.io  and follow the  \ninstructions there. Once you have it installed, fire up a terminal in the same directory \nas your code and run karma start , then sit back and watch the magic happen.\nWell, sort of. Likely what really happened was you got an error saying it couldn't \nfind your config file. Karma is designed to let you specify different configurations \nfor each project. Many of the options are more niche than we're going to cover in this \nchapter, but let's walk through some of the basic options that need to be defined for \nevery project.\nGood Karma – Testing in AngularJS\n[ 66 ]\nConfiguration By default, Karma looks for a configuration file\n called  karma.conf.js , and  \nwhile you can name it whatever you want, we're going to stick with that for the \n \nsake of convenience. To create your initial file, run \nkarma init  in your project \ndirectory and answer the questions appropriately. For this chapter, I'll be using \n \nthe following configuration:\n• Testing framework: Jasmine • Use Require.js: no • Browser: Chrome • Files to test: test\/spec\/**\/*.js\n• Watch files and run on change: yes These are the defaults for my current version of Karma, though they may change \n \nby the time you're reading this. When you specify which file pattern to watch, \n \nit will likely create a warning that it can't find any files that match that pattern. \n \nThat's ok, we'll get to that in a moment. First, we need to create our code directory, \nimport Angular, and finally tell Karma to grab our libraries so it can process our \ncode correctly. Angular and Karma\nFirst, go ahead and create a directory called \napp, where we'll store all our  \napplication code. Within that, let's create a \ncomponents  directory for Angular (and \njQuery if you need it) and a scripts  directory for all our custom code. Go ahead \nand import your  angular.js  file, as well as the angular-mocks  file  included in your \nAngular download (if you just downloaded the base \nangular.js  file, you'll need to \ngo back to http:\/\/www.angularjs.org  and download the entire ZIP package).\nSome of you may recognize this filesystem pattern as the one \nfollowed by Bower (http:\/\/bower.io ), an awesome browser \npackage manager by Twitter. We don't have time here to dive into it \ndeeper, but I highly recommend you look into it as you go forward in \ndeveloping your web applications.\nOnce you have everything included, your directory structure should look something \nlike the following: myAwesomeApp\/ -- test\/\nChapter 8\n[ 67 ]\n---- spec\/ ------ directives\/ -------- directives.js (currently an empty file)\n-- app\/ ---- components\/ ------ angular\/ -------- angular.js ------ angular-mocks\/\n-------- angular-mocks.js\n---- scripts\/ ------ app.js (currently an empty file)\n------ directives\/ -------- directives.js I've gone ahead and created a couple of empty \ntest and app files as well. You're \nwelcome to organize your app and test directories however you want, although \n \nI do recommend keeping them  in a similar structure to help you remember which \nfiles test which parts of your application.\nNow that our directory structure is in place, we need to finish telling Karma which \nfiles to include. Go ahead and open \nkarma.conf.js  again in a text editor and find  \nthe files array. Right now it should just have one entry, corresponding to the test \n \nfile pattern we specified in the previous paragraph. Now, before that entry, let's \n \nadd the file patterns for our application scripts, so it should read like this:\nfiles = [   'app\/components\/angular\/angular.js',\n  'app\/components\/angular-mocks\/angular-mocks.js',\n  'app\/scripts\/*.js',\n  'app\/scripts\/**\/*.js',\n  'test\/spec\/**\/*.js'\n];And, just like that, Karma is ready to run. That said, a test setup without any tests \n \nis obviously not particularly helpful, so let's go ahead and create our first test.\nIf the idea of writing a test before you've even written any application \ncode seems backwards to you, I highly recommend doing some \nresearch into Test Driven Development  (TDD) online. We don't have \ntime to cover it all here, but it is the approach we'll use for these two \nchapters and our final app in the last chapter.\nGood Karma – Testing in AngularJS\n[ 68 ]\nMy first test\nThere are two primary types of tests supported by Angular and Karma: Unit and E2E \n(end-to-end). Unit testing is concerned with testing small chunks of code to ensure \nthey do, and continue to do, what they're supposed to do. We'll do a quick overview \nof those next, and then dive into them in more detail in the next chapter. After our \nunit testing overview, we're going to introduce Angular's approach to E2E testing, \nwhich ensures that your whole application has and maintains all its functionality. \nBecause E2E testing  is more focused on an entire application, and not just a single \ndirective, we won't spend too much time with it here, but it is worth being familiar \nwith as you go forward.\nOk, let's take a look at some code. Jasmine allows you to have multiple test blocks, \neach of which is housed in a describe  call. Usually you would use one test block \nper module of code, unless you have some modules of either very large or very small \nsize. For our purposes, we'll wrap all our directive tests in one \ndescribe  call, so that \nour initial test\/spec\/directives\/directives.js  file looks like the following:\ndescribe('My Tested Directive', function () {\n});Since we're going to be testing a directive, we'll need access to the compilation \nprocess, as well as a scope to work with. Luckily for us, the \nangular-mocks  package \nwe included provides the same dependency injection functionality that we've \ncome to appreciate so much in our application code, using the \ninject  method as \nhighlighted in the following code snippet:\ndescribe('My Tested Directive', function () {\n  var $compile, $rootScope;\n  \/\/Require the module our directive is attached to\n  beforeEach(module('myApp'));\n  \/\/The inject function strips away the underscores, which allows us\n  \/\/to avoid any scoping confusion\n  beforeEach( inject(function (_$compile_, _$rootScope_) {\n      $compile = _$compile_;\n      $rootScope = _$rootScope_;\n    })); });\nChapter 8\n[ 69 ]\nThe module  method is also provided by the angular-mocks  package, and bootstraps \nour Angular app for us before running each of the tests. The mocks package provides \na few other utilities for testing which we won't cover here, but are helpful if you \ndive into more complex testing situations and are documented as part of the official \nAngular documentation. Finally, the \nbeforeEach  method  is part of the Jasmine \nframework itself and, as you might guess by the name, executes before each test runs, \nallowing us to perform any necessary setup or data normalization before continuing.\nNow that we have everything wired up, let's go ahead and write our first unit test. \nFor this directive, we're going create another listing directive, much like out tweet \nwidget from Chapter 2 , The Need for Directives , except this time it's a list of players, \nand we'll build the entire widget as a tested directive, instead of just generic \n \nAngular code. Our first test simply confirms that our directive compiled correctly.\ndescribe('My Tested Directive', function () {\n  … \/\/setup code   \/\/We'll use this template for all our tests\n  var directiveTpl = '<div player-widget=\"playerList\"><\/div>';\n  it('should create player widget element', function () {\n    var $scope = $rootScope.$new();\n    \/\/The passing a template into $compile returns a \"linking\" \nfunction that can     \/\/be used to take a scope and apply it to the template\n    var $element = $compile(directiveTpl)($scope);\n    \/\/Now the actual test\n    expect($element.html()).toContain('class=\"player-widget\"');\n  });});Now, if Karma is running in the background, you'll see it noticed the new test, ran it, \nand found the result a bit disappointing. That, of course, is exactly what we expected, \nsince we haven't defined our directive or its actual template yet. In order to prevent \nour dear test runner from being sad for too long, let's go ahead and build that out. In \nour scripts\/app.js  file, we need to create a module named \nmyApp, and then in the \nscripts\/directives\/directives.js  file, we'll create our actual directive. As an \nexercise to test your progress on the path to directive mastery, go ahead and build \npart of the directive yourself so that our tests start passing. If you get stuck, don't \nworry, we'll walk through all the code shortly, but first, try it yourself, and then \n \nwe'll write a few more tests.\nGood Karma – Testing in AngularJS\n[ 70 ]\nMocking data\nOften when we're testing different pieces of an application, we need to validate how \nthat piece responds to specific data input. We don't however, want to be dependent \non an external source for that data; there's nothing worse than spending several \nhours trying to debug your failing tests only to realize that your third-party data is \ncorrupt. Because of this, whenever possible we want to use mocked sample data for \nour tests so that we can be sure of the validity, or invalidity if we're negative testing, \nof the input our directive is receiving.\nAs a side note, whenever possible your directive should not be \nresponsible for actually retrieving the information. Angular provides \nservices as a more modular way of handling information, and they \nalso make it significantly easier to test. We don't have time for a full \ndiscussion of services here, but the short answer is if you find yourself \nrequiring $http into your directive, it's time to create a service.\nIn our case here, we'll want to mock the player JSON data that gets passed into our \nwidget. For convenience' sake, we'll include our sample data in the same file as our \ntest, but if you have lots of sample data I recommend keeping it in separate files and \nloading it into your test runner via the \nkarma.conf.js  config as discussed previously.\nFor our next two tests then, we want to ensure that our directive properly received \nthe player list, and that it correctly generated the corresponding DOM elements.\ndescribe('My Tested Directive', function () {\n  … \/\/setup work and first test\n  var playerList;   beforeEach(function () {\n    \/\/We want to set this before each test, in case we need to \nmanipulate it     playerList = [       { \"name\" : \"Babe Ruth\", \"team\" : \"Yankees\" },\n      { \"name\" : \"Jackie Robinson\", \"team\" : \"Dodgers\" },\n      { \"name\" : \"Hank Aaron\", \"team\" : \"Braves\" }\n    ];   });  it('should scope playerList to players', function () {\n    var $parent = $rootScope.$new();\nChapter 8\n[ 71 ]\n    $parent.playerList = playerList;\n    var $element = $compile(directiveTpl)($parent);\n    var $directiveScope = $element.scope(); \/\/Angular provides the \nscope() method to retrieve an element's scope\n    expect($directiveScope.players).toBeDefined();\/\/Confirm we have a \nnew property     expect($directiveScope.players.length).toEqual(playerList.\nlength);\/\/Confirm our list is the same length\n  });  it('should generate player elements for each player', function () {\n    var $scope = $rootScope.$new();\n    $scope.playerList = playerList;\n    var $element = $compile(directiveTpl)($scope);\n    \/\/We're outside of the angular $watch loop here, so we need to \ncall $digest manually\n    $scope.$digest();\n    \/\/the jQLite wrapper provided by angular can only find elements by \ntag name. If you're including jQuery, you'll have access to those full \nmethods instead     var $players = $element.find('p');\n    expect($players.length).toEqual(playerList.length);\n    expect($players.eq(0).text()).toContain('Babe Ruth');\n  });});Before we go on, a quick  note about testing objects and using equality. Jasmine is \ngood about using an object's properties, not its reference, to test for equality. That \nsaid, the ng-repeat  directive adds an extra $$hashKey  property to each item for \ncaching purposes, so if you're going to test a property that you iterate over (like we \ndo here), it likely won't be the same as what was passed in, which is why we used \ndefinition and length tests, instead of just \nexpect($directiveScope.players).\ntoEqual($parent.playerList) . The test subject\nOk, so we've once again caused our poor test runner extensive grief and anguish \n \n(we now have two failing tests, not just the paltry one from earlier), so let's dive \ninto our directive code and see how this all fits together. As a confirmation to what \nyou've hopefully already coded, the \nscripts\/app.js  file should be one simple line:\nangular.module('myApp', []);\nGood Karma – Testing in AngularJS\n[ 72 ]\nAnd then our final scripts\/directives\/directives.js  file should have come \ntogether somewhat similar to the following:\nangular.module('myApp')\n  .directive('playerWidget', function () {\n    \/\/Define our template for the widget\n    var tpl = '<div class=\"player-widget\">' +\n      '<p class=\"player\" ng-repeat=\"p in players\">' +\n        '{{p.name}} ({{p.team}})' +\n      '<\/p>' +     '<\/div>';     return {       template : tpl,\n      scope : {         'players' : '=playerWidget'\/\/Declare our two-way binding, and \nnothing else       }     }   });With that, we're going to press  pause on our study of unit testing. We'll dive back in \nmore deeply in the next chapter, but first, I want to introduce the Angular Scenario \ntest runner, and its usage for E2E testing.\nE2E testing For E2E testing, Angular provides a testing suite called the Scenario Runner , which \nis essentially a collection of utilities to navigate your application and interact with it \nprogrammatically, so that you can test functionality from the user's point of view as \nwell, and not just at the code level.\nTo get the Scenario Runner configured, go ahead and copy your current \nkarma.\nconf.js  to karma-e2e.conf.js . This testing setup requires a few different files to \noperate, and it's generally recommended to keep your two configurations separate \nfor modularity and ease of testing. Open your new configuration file and replace \njasmine  with ng-scenario  in the frameworks  array. You can also remove all the \napplication files from the include, as we're going to be loading our app directly this \ntime, so those includes are all handled via the application itself. Now is a good time \nto also create an e2e directory under your test folder and update the test path to \nmatch it. Our files array should now have only one element:\nfiles = [   'test\/e2e\/**\/*.js' ];\nChapter 8\n[ 73 ]\nNow, there's one last thing we need to do to get this all running, and that's make \nsure our app is hosted somewhere that a browser can access. To do this, set up a \nproxy between what Karma sees as your application root and the actual web address \n(including port) for your application. The following two examples are for Apache \nand node.js  servers. If you get stuck, a quick Google search for your specific setup \nshould point you in the right direction.\n\/\/Included in your karma-e2e.conf.js file (only use one of the \ntwo below) proxies : {   '\/': 'http:\/\/localhost\/my-app\/' \/\/ For apache\/nginx\n  '\/': 'http:\/\/localhost:8080\/' \/\/ For node.js\n}Now that Karma is all set for our E2E testing extravaganza, let's give it something \n \nto work with.If you get an error when running this configuration that says \nNo provider for \"framework:ng-scenario\" , execute \nnpm install  karma-ng-scenario karma-ng-html2js-\npreprocessor  in your application directory, and then run \nkarma \nstart karma-e2e.conf.js  again. Scenarios We'll start by testing the same functionality we covered in the previous\n section, \nexcept now from the browser's point-of-view. We'll need to have an actual \nindex.\nhtml file which contains our widget, so go ahead and create that now if you're \nfollowing along (and you are, of course, aren't you?). Then let's create our first \n \nfew tests as follows:\ndescribe('My Tested Widget', function () {\n  beforeEach(function () {\n    browser().navigateTo('..\/..\/app\/index.html');\n  }); \/\/ Tell our testing browser to load the index file\n  it('Should display the widget', function () {\n    expect(element('.player-widget').count()).toBe(1);\n  });  it('Should display 3 players', function () {\n    expect(repeater('.player-widget .player').count()).toBe(3)\n  }); });\nGood Karma – Testing in AngularJS\n[ 74 ]\nSo far everything looks pretty much the same as our previous unit tests, except that \nnow everything is already compiled and we don't have to worry about generating \nall our elements. Another gotcha to be aware of is that while these tests look just like \nJasmine, they have one key difference: \nexpect  here requires a future, not a value. \nWhat this means is that the usually tautological test of \nexpect(true).toBe(true)  \nwill actually fail, because the first \ntrue is a value. Instead, the Scenario Runner \nversion of expect  requires a future, or promise, which will eventually resolve to a \nvalue and it's that resolved value that gets tested against the expectation. If you're \nnot familiar with promises, I recommend taking some time to learn about them, as \nboth Angular and jQuery (and several other JavaScript libraries) use them for nearly \nall asynchronous processing.The Scenario Runner uses them because it actually \nqueues up all the tests, and then runs through them, instead of just processing them \nas it reads them, so the values need to be resolved asynchronously. All the standard \nScenario Runner methods return futures, so usually you won't need to worry \nabout \nit, but it is something to be aware of as you start developing more complex tests.\nFinally, let's add one more test, looking at actual user interaction. Suppose we want \nto highlight a player when the user clicks on it. As you can see in the following code \nsnippet, the Scenario Runner provides many of the same methods you might have \nused in jQuery DOM manipulation, such as \nclick and attr:\n  ...  it('Should highlight a player when clicked', function () {\n    var p = element('.player-widget .player:first');\n    p.click() ;     expect(p.attr('class')).toContain('highlighted') ;\n  });  …Just like that, we've loaded our page, interacted with it, and tested the result. I'll \nleave it to you to update our widget directive with the code to satisfy Karma's need \nfor properly executing code. Summary So now we've introduced Karma, gone over its basic configuration options, and \nlooked at the basics for both unit and E2E testing. While unit testing allows us to \nvalidate the data-model, E2E testing lets us test what the user actually sees, in a \n \nway that's fast and reliable. Next, we'll dive into unit testing in more detail, looking \nat how we can use it to ensure both accurate and corrupt data is handled cleanly \n \nby our directives.\nA Deeper Dive into  Unit Testing\nIn the previous chapter we discussed the basics of testing with Angular, including \nhow to set up Karma and write your first few unit and E2E tests. For the next few \npages we're going to dive deeper into the realm of unit testing, taking a look at \n \nsome of the ways being data-driven makes our lives easier, and how striving to \n \nmake our code easy to test will also directly lead to our code also being more \nmodular and extensible. We'll continue using Jasmine for all our tests here, and \nmany of the examples we cover will be helpful for testing in all frameworks, \n \nnot just Angular, although of course that will be our primary focus.\nHighlighted, again\nAt the end of our discussion on E2E testing\n, we added the ability to highlight each \nplayer when a user clicked on it. I left it up to you to implement the directive code \n \nto create that functionality, and hopefully by now you've done so. There are a couple \nways you might have gone about it and, if you're used to the DOM manipulation \nmethod of user-interaction, you might have written something like the following:\ndirective('playerWidget', function () {\n  var tpl = '<div class=\"player-widget\">' +\n    '<p class=\"player\" ng-repeat=\"p in players\">' +\n      '{{p.name}} ({{p.team}})' +\n    '<\/p>' +   '<\/div>';   return {     template : tpl,     scope : {\n[ 76 ]\n      'players' : '=playerWidget',\n    },     link : function ($scope, $element, $attrs) {\n      \/\/When a user clicks the player tag, add the highlighted class\n      $element.on('click','.player', function (ev) {\n        jQuery(ev.currentTarget).addClass('highlighted');\n      });    }  }});And while that method  will work, and even passes our E2E tests, nothing in \n \nthe data-model itself actually changes to correspond to the highlighted state, \n \nwhich makes it virtually impossible to test from a strictly data-model perspective, \nmaking unit testing worthless for this functionality.\nWhat Angular encourages, both from a modularity perspective and for ease of \ntesting, is a more data-driven approach. Consider the following example instead, \nwith the changed portions highlighted:\ndirective('playerWidget', function () {\n  var tpl = '<div class=\"player-widget\">' +\n      '<p class=\"player\" ng-repeat=\"p in players\" ng-\nclass=\"{highlighted : p.active}\" ng-click=\"activate(p)\n\">' +\n        '{{p.name}} ({{p.team}})' +\n      '<\/p>' +     '<\/div>';   return {     template : tpl,     scope : {       'players' : '=playerWidget',\n    },     link : function ($scope, $element, $attrs) {\n      \/\/When a user clicks, set the active flag on the player object\n      $scope.activate = function (player) {\n        player.active = true;\n      }     }  }});\n[ 77 ]\nNow we can write a simple test to validate our activate method as follows:\nit('should activate the player', function () {\n    var $scope = $rootScope.$new();\n    $scope.playerList = playerList;\n    var $element = $compile(directiveTpl)($scope);\n    var $directiveScope = $element.scope();\n    var firstPlayer = $directiveScope.players[0];\n    \/\/First validate that the active property is either false or \nundefined     expect(firstPlayer.active).toBeFalsy();\n    $directiveScope.activate(firstPlayer);\n    \/\/Now confirm that we've set that same property to true\n    expect(firstPlayer.active).toBe(true);\n  });This approach to  development and testing allows us to use unit tests to confirm \nthat our data-model is accurate and properly manipulated, and then use E2E tests \nto validate the end result. As your applications get more complex, when something \nbreaks an E2E test, you'll want unit tests like these to help highlight exactly where \nthe problem is, instead of having to walk through a long function chain step-by-step.\nNegative testing\nGenerally, when we first start testing, we think of all the things that need to happen \nand then test for them, which is an awesome start. What we often forget however, is \nthat we need to decide, and test for, what happens when something goes wrong, or \nwhen that 'it-could-never-happen' case happens. Consider our player list and what \nwould happen if we received a player object without a team. There are plenty of \nreasons why this might happen—they're undrafted, a database corruption, or your \ndata-entry intern missed their coffee that morning—but, whatever the reason, we need \nto make sure our directive can handle it cleanly. Right now, if we were to pass that in, \nwe'd end up with the following rather unprofessional output:\n...<p class=\"player\">John Smith ()<\/p>\n...Since we'd rather not have a bunch of empty parentheses floating around in our \napplication, let's update our directive and tests to only display the team name, \n \nand wrapping parentheses, when there's actually a team value associated with \n \nthat player.\n[ 78 ]\nFirst, let's write our test and see what that tells us.\n…var playerList; beforeEach(function () {\n  \/\/We've updated this to include a fourth player without a team\n  playerList = [     { \"name\" : \"Babe Ruth\", \"team\" : \"Yankees\" },\n    { \"name\" : \"Jackie Robinson\", \"team\" : \"Dodgers\" },\n    { \"name\" : \"Hank Aaron\", \"team\" : \"Braves\" },\n    { \"name\" : \"John Smith\"}\n  ];});…it('should display team when present', function () {\n  var $scope = $rootScope.$new();\n  $scope.playerList = playerList;\n  var $element = $compile(directiveTpl)($scope);\n  $scope.$digest();   var $players = $element.find('p');\n  expect($players.eq(0).text()).toContain(playerList[0].team);\n});it('should not display team when not present', function () {\n  var $scope = $rootScope.$new();\n  $scope.playerList = playerList;\n  var $element = $compile(directiveTpl)($scope);\n  $scope.$digest();   var $players = $element.find('p');\n  expect($players.eq(3).text()).not.toContain('()');\n});Naturally, if we run this right now, it will fail. More importantly, however, it also \nfeels very fragile. Testing for the existence of \n'()' makes us very dependent on the \nspecific styling implementation, and means that a layout change could easily \nbreak  \nour tests without actually breaking any of the real functionality in our code. With \nthat in mind, let's try to update our directive template a bit and see if we can make it, \nand our test, more flexible.\n[ 79 ]\nThe main problem we have in the preceding example is that our team description \nis just hanging out there all by itself, so a simple fix would be to wrap it in a DOM \nelement that we can easily query for.\n…var tpl = '<div class=\"player-widget\">' +\n  '<p class=\"player\" ng-repeat=\"p in players\" ng-click=\"activate(p)\" \nng-class=\"{highlighted : p.active}\">' +\n    '{{p.name}} <span class=\"team\" ng-show=\"p.team\">({{p.team}})<\/\nspan>' +   '<\/p>' + '<\/div>'; …Wrapping our team name up in its own element allows us to create much cleaner \nand more flexible tests, which won't break the moment we need to change our \nparentheses to brackets or remove  them altogether.\nit('should display team when present', function () {\n  var $scope = $rootScope.$new();\n  $scope.playerList = playerList;\n  var $element = $compile(directiveTpl)($scope);\n  $scope.$digest();   var $players = $element.find('p');\n  var teamNode = $players.eq(0).find('span');\n  expect(teamNode.text()).toContain(playerList[0].team);\n});it('should not display team when not present', function () {\n  var $scope = $rootScope.$new();\n  $scope.playerList = playerList;\n  var $element = $compile(directiveTpl)($scope);\n  $scope.$digest();   var $players = $element.find('p');\n  var teamNode = $players.eq(3).find('span');\n  expect(teamNode.css('display')).toBe('none');\n});\n[ 80 ]\nSummary Obviously, these few pages are far too short to dive very far into the complexities of \nunit testing; hopefully, however, this has given you a taste of the various approaches \nyou can take and reinforced for you why our original principle of data-driven \nmodularity is so important. As a final note on testing, because we're using Jasmine \nfor all our unit tests, all of Jasmine's functionality is still available, including custom \nmatchers and spies. In the next chapter, we're going to wrap-up our study on \ndirectives by building a full featured module from scratch, making use of everything \nwe've learned so far, and discovering a few new awesome tricks along the way as well.\nBringing it All Together\nCongratulations. You've made it nearly the entire way through our study of \nAngular \nDirectives. No doubt some parts are still somewhat confusing, and there are likely \nother areas you're already tired of hearing about (did I mention that you should \npractice data-driven modularity?), but despite all that, hopefully you've come this \nfar excited about the possibilities in front of you. Whether you intend to spend the \nrest of your days with Angular or just wanted to gain a different perspective that \nyou can take back to the framework in your life, hopefully this book has been an aid \nin that process so far. What I want to do for this chapter now is to walk through the \nentire directive creation process, from our first tests all the way through to a complete \nmodule. I highly encourage you to follow along with your own development tools \nof choice, but if you get stuck or want to come back and review something, all of the \ncode created in this chapter is available at \nhttps:\/\/github.com\/mrvdot\/angular-\ncontent-grid\/ . We'll be working through an actual Angular module that's live on \nGitHub , so the final code here will likely be different from what you see online. To \nhelp you see each step as we progress, I've created tags within the repository that you \ncan use to track our progress throughout this chapter. If you want to be able to follow \nalong with each step, go ahead and run the following code in your working directory \nbefore moving on: # git clone https:\/\/github.com\/mrvdot\/angular-content-grid\/\n….# cd angular-content-grid\n# git checkout blankRepo The last command will update your working directory to the \nblankRepo  tag,  \nwhich represents the initial commit with nothing more than a \nREADME  file.\nIf you don't use git, or have simply downloaded the code packet \nfor this book already, all the branches have been included in the \nC10 directory within that packet as well.\n[ 82 ]\nAngular content grid\nFor this chapter then, we're going to build a content grid, utilizing the awesome \njQuery Masonry plugin by David DeSandro. At the end, we want the ability to \npass in a dynamic array of HTML elements, display them, trigger Masonry to \norganize them properly, and communicate with the rest of our app that everything \nis processed and ready, allowing for custom hooks into the Masonry process. Once \ndone, we should be able to  render multiple elements on to a page like you see here:\nDiving in With that, let's go ahead and dive into \nwriting some code to build this... Wait, you \nknow better than that. We just spent two chapters on the value of testing and the \nimportance of writing those tests before our code; surely you haven't forgotten \nall that already. So instead, let's write up some unit tests to serve as our initial \nspecification. If you're following along on your own machine, you'll need to setup \nKarma as before, or just copy our last setup over and rename the files. Once you \n \nhave that ready and Karma running, let's create a unit test file with two initial tests:\ndescribe('Content Grid', function () {\n  var $compile     , $rootScope     , tpl = '<div content-grid=\"elements\"><\/div>'\n    , elements = [];   beforeEach(module('mvdContentGrid'))\nChapter 10\n  beforeEach(inject(function (_$compile_, _$rootScope_) {\n    $compile = _$compile_;\n    $rootScope = _$rootScope_;\n  }));  describe('Basic compilation', function () {\n    it('should scope elements correctly', function () {\n      var $parScope = $rootScope.$new();\n      $parScope.elements = elements;\n      $parScope.otherProperty = \"should be undefined\";\n      var $el = $compile(tpl)($parScope);\n      var $scope = $el.scope();\n      expect($scope.elements.length).toBe($parScope.elements.length);\n      $parScope.elements.push({\"test\" : \"item\"});\n      expect($scope.elements.length).toBe($parScope.elements.length);\n      expect($scope.otherProperty).toBeUndefined();\n    });    it('should compile template with elements', function () {\n      var $parScope = $rootScope.$new();\n      $parScope.elements = [\n        {           title : \"TITLE\",\n          id : 1,           content : \"<p>CONTENT<\/p>\"\n        }       ]       var $el = $compile(tpl)($parScope);\n      $rootScope.$digest();\n      var gridElements = $el.find('[content-grid-element]');\n      expect(gridElements.length).toBe($parScope.elements.length);\n      var first = $parScope.elements[0];\n      expect(gridElements.eq(0).data('element-id')).toBe(first.id);\n      expect(gridElements.eq(0).find('.title').text()).toBe(first.\ntitle);       expect(gridElements.eq(0).find('.content').html()).\ntoContain(first.content);\n    });   });});\n[ 84 ]\nThese two initial tests ensure a few basic things about our directive. First, that it \nwill initialize and be properly scoped. We do this by testing for the existence and \nproper linkage of the elements  property that we want to be passed through, as \nwell as ensuring that other properties don't make it through to our directive's scope. \nSecondly, we use the second test to validate that our content grid will iterate through \nall the elements and create actual DOM grid elements containing their content. You \nmay notice that we've used jQuery selectors instead of sticking with the standard \njqLite selectors provided within Angular. This is because we'll use jQuery within the \ndirective itself, and since its selectors are significantly more powerful, I find it makes \nthe testing code much cleaner to use those instead.\nYou may also have  noticed that at this point our tests do nothing to test for the \nMasonry functionality. There are two main reasons for this, and as you go forward \nwith Angular directives you'll likely find these apply to almost any directive with a \nsignificant third-party plugin component integration:\n1. First, we (or, at least, I) simply don't know how Masonry operates well \nenough yet to know how to test for it. This is often the case when integrating \nwith plugins, and for this I find it easier and more efficient to simply set the \nintegration tests aside until we've actually connected it (even if only through \nthe browser development tools) and can better say how it's working on \n \nour element(s). 2. Secondly, we're just not ready yet. Our goal at this point is to create a \nworking directive, and while the integration is a key piece of that, it's not \nthe first step. My strategy for TDD is write one or two tests, then the code \nto satisfy those, and then go on. Some people have recommended writing \nout the entire specification in tests first, and while you're certainly welcome \nto experiment with that, I usually find that that can cause almost as much \nfrustration as not testing at all. The initial directive\nNow that we have our first couple tests ready and running, let's move forward with \nthe directive code. I won't include every line of the directive here, just the key pieces \nfor the sake of space. To review all the code, run \ngit checkout initialTests  \nwithin your cloned repository directory. Now, without further ado, the directive is:\nChapter 10\nangular.module('mvdContentGrid', ['ngSanitize'])\n  .directive('contentGrid', function () {    \n    return {       template : \/* … *\/,\n      replace : true,\n      scope : {         'elements' : '=contentGrid'\n      }     }  })  .directive('contentGridElement', function () {\n    return {       template : \/* … *\/,\n      replace : true,\n      scope : {         'contentElement' : '=contentGridElement'\n      },       link : function ($scope, $element, $attrs) {\n        $element.data('element-id', $scope.contentElement.id);\n      }     }  });There are a  couple important things here to notice. First, we have required \nngSanitize  into our module, which provides us with the ability to bind filtered \nHTML to an element. Any time you're going to be binding HTML straight from \na data source to your elements, I highly recommend you use the sanitize filter to \nensure no malicious, or even just malformed, code gets in. To see how exactly we're \nusing it within this directive, check out the template for the\n content-grid-element  \ndirective. Secondly, we're using two separate directives for additional modularity. \nThis isn't always necessary but, in many cases I do recommend using this approach \nto help separate out responsibilities and keep your code cleaner. Finally, you may \nwonder why we used the .data()  method on our element, when everything is \nsupposed to be pulled directly from the data-model anyway. In short, it's because \nwe often integrate with plugins\/libraries that don't have easy access to the Angular \nscope, and for small data pieces such as an ID, making them easily retrievable to \nthird-party plugins actually tends to help keep our code more modular, rather \n \nthan less.\n[ 86 ]\nConnecting Masonry\nAt this point, we have a functioning directive that takes an array of content elements \nand displays them. That's great, but it's \nstill missing the key piece: our Masonry \nintegration. If you haven't already, go ahead and download the packaged JavaScript \nfile from  http:\/\/masonry.desandro.com . While Masonry can also be installed \nusing Bower, it has several dependencies and requires a fuller build process, which is \noutside the scope of this book, so for now we'll just use the already packaged file.\nAny time you want to connect a DOM manipulation plugin, there are a few things \n \nto keep in mind: 1. Identify both the initialization and update methods for your plugin. \nSometimes these are the same.\n2. Evaluate if the plugin needs to be told explicitly about changes, or if it will \ndetect them itself. 3. Set up the appropriate watchers to initialize and update your plugin.\nTo do this, we'll use both the controller  and link properties of our content-grid  \ndirective. The shared controller  function allows us to manage all the options in a \nway that can be accessed by each of the element directives easily, as well as provide \nany connection methods we might need. We use \nlink, however, because we know it \nwon't be called until our element is fully compiled and inserted into the DOM, so we \ncan safely call our initialization methods there. At this \nstage, our directive definition \nhas been updated to the following:\n…scope : {   'elements' : '=contentGrid',\n  'userOptions' : '=options'\n},require : 'contentGrid',\ncontroller : function ($scope, $element, $attrs) {\n  var ctrl = this;   var defaults = {     columns : 4,\/\/How many columns should we have\nChapter 10\n    columnWidth : 0,\/\/Set this to force a specific column width, \ninstead of calculating based on columns property\n    gutter : 0   };  ctrl.options = angular.extend({}, defaults, $scope.userOptions || \n{});},link : function ($scope, $element, $attrs, ctrl) {\n  if ($scope.elements.length) {\n    setTimeout(initOrUpdateMasonry);\n  };  var initialized = false;\n  var initOrUpdateMasonry = function () {\n    if (!initialized) {\n      var opts = {         columnWidth : ctrl.options.columnWidth || ($element.width() \/ \nctrl.options.columns),\n        itemSelector : '.grid-element',\n        gutter : ctrl.options.gutter\n      };       initialized = $element.masonry(opts);\n    } else {       \/\/Already initialized, just update\n      $element.masonry('reloadItems');\n      $element.masonry('layout');\n    }  };  $scope.$watch('elements', function (newValue, oldValue) {\n    \/\/Check to confirm that we actually have an array of elements to \nwork with     if (newValue) {       initOrUpdateMasonry();\n    };   });}…\n[ 88 ]\nTo see the full code at this point, use git checkout masonryConnected  to update \nyour repository directory. Note that we've provided an \noptions  attribute property \nto allow users to pass in a map of options much like they normally would to a \njQuery plugin, and we can extend it with our own defaults and then pass it along \nto the plugin. Whenever you're creating an integration between Angular and a \nplugin, I highly recommend you follow this pattern, as otherwise you'll find yourself \nadding several attributes and flags to account for control of each option, instead \nof a single map to handle all of them. We also setup our \ninitOrUpdateMasonry  \nmethod  to properly apply our plugin options and also request that Masonry update \nits internal cache of items and then apply a new layout. If you prefer, you can split \nthe initOrUpdate  method  into two separate calls, or even call the initialize portion \nimmediately upon loading your directive, however when working with a plugin such \nas Masonry that doesn't perform any action until we actually have HTML content for \nit to work on, I prefer to delay initialization as long as possible. In my experience that \nleads to more performant applications, since the browser doesn't have to hold any \nadditional objects or functions in memory until they're actually useful.\nTesting Masonry\nAt this point we want to begin testing our plugin integration itself. Masonry doesn't \nprovide any direct data-model changes that we can use to cleanly validate it via \nunit tests, so now seems like a good time to begin our E2E testing process. We want \nto validate our basic directive compilation as before, but also confirm that the grid \nelements are being modified by Masonry, which results in the three following tests:\ndescribe('Content Grid', function () {\n  beforeEach(function () {\n    browser().navigateTo('\/examples\/');\n  });  it('should contain compiled content grid', function () {\n    var grid = element('.content-grid');\n    expect(grid.count()).toBe(1) ;\n  });  it('should contain two grid elements', function () {\n    expect(element('.grid-element').count()).toBe(2);\n  }) ;\nChapter 10\n  it('should have applied masonry', function () {\n    expect(element('.grid-element:first').css('position')).\ntoBe('absolute')   }) ; });The first thing you'll notice  is that I'm using my examples directory as my test basis. \nWhile sometimes a specific test HTML file is more appropriate and\/or cleaner, I find \nthat using my examples directory as my E2E testing directory helps ensure that not \nonly is my directive\/application fully tested, but also that all the examples I provide \nto other developers are fully functional and correct as well. It also has the reverse \neffect of making sure my examples cover all the major functionality, since I want all \nof those pieces to be tested.\nNext, take a look at the third test. This one will be different for every plugin you \nintegrate. Some will add a class—those are some of the easiest to test. Some, such \nas Masonry, require that you test for a specific attribute or characteristic. While this \nisn't quite as clean and stable as testing for a specific class, unless you intend on \nabsolutely positioning your elements manually, which begs the question of why \nyou're even using Masonry in the first place, this kind of test will still suffice.\nEvents When we first started this chapter, we said that we wanted to be able to hook into \nspecific events. Masonry itself only provides two \nevents, one when everything is \nlaid out and one when an item is removed. Instead of Masonry events then, we'll \ncreate our own, starting with one for when it's first initialized, and another that fires \nanytime there's an update. Per usual, let's go ahead and write our unit tests first and \nthen we'll update the directive code to satisfy them:\ndescribe('Events', function () {\n  var initEvent = 'masonry-initialized'\n    , updateEvent = 'masonry-updated';\n  it('should not fire ' + initEvent + ' event when initialized with no \nelements', function () {\n    var $parScope = $rootScope.$new();\n    var initialized = false;\n    $parScope.$on(initEvent, function () {\n        initialized = true;\n    });\n[ 90 ]\n    var $el = $compile(tpl)($parScope);\n    $rootScope.$digest();\n    expect(initialized).toBe(false);\n  }) ;  it('should fire ' + initEvent + ' event when initialized with \nelements', function () {\n    var $parScope = $rootScope.$new();\n    $parScope.elements = [ … ]\n    var initialized = false;\n    runs(function () {\n      $parScope.$on(initEvent, function () {\n        initialized = true;\n      });        var $el = $compile(tpl)($parScope);\n      $rootScope.$digest();\n    });     waitsFor(function () {\n      return initialized;\n    }, 'Initialized should have been fired', 200);\n    runs(function () {\n      expect(initialized).toBe(true);\n    })   });   \/* … Repeat for update event ... *\/\n});I've introduced a few new Jasmine testing methods here and if you're not \naccustomed to asynchronous testing within Jasmine, you likely haven't seen \nruns \nand waitsFor  blocks before. Because the  Angular $emit and $broadcast  methods \nhappen asynchronously, we need to run the code that should trigger the message \nwithin a run block, then tell Jasmine to wait until \ninitialized  returns true or 200 \nmilliseconds pass, whichever comes first. If we time-out before \ninitialized  has \nbeen set to true, the second parameter gets passed back as a failure message.\nFor the sake of space, I'll let you implement the messaging system on your own, \nalthough of course if you need a guide you can checkout the \nmessagingEvents  git \ntag to see our final code.\nChapter 10\nTiming I mentioned earlier that one of the reasons why I like using my examples directory \nas my basis for all E2E tests is that it helps ensure the quality of my code and my \nexamples at the same time. As a prime example of this, when I added a logging \nelement to my examples so I could demonstrate the use of our new initialized and \nupdated events, I discovered that Masonry wasn't running quite as seamlessly as \nI'd originally imagined. The log was positioned right in the middle of the content \ngrid, even though our elements extended far below that point. It turns out that even \nthough Masonry was accurately positioning our elements, it was operating before all \nthe element content had been compiled, and thus it miscalculated the proper height \nto apply to our grid. I noted in the first few chapters that any time you're applying \na DOM manipulation plugin, it's often best to wrap it in a \nsetTimeout  method  to \nensure it operates after the compilation process it done. I had, however, forgotten to \nfollow that advice when first setting everything up, and so while our \ncontent-grid  \nelement was ready for manipulation, the internal \ncontent-grid-element  directives \nwere still compiling and thus were not yet at their full height.\nWrapping the initOrUpdateMasonry  method  was simple enough; if you look at the \ncode you just checked out you'll see that our watcher now includes the \nsetTimeout  \nwrapper. I also wanted to ensure I didn't somehow break that layout again later, \nhowever, so I added one more additional E2E test to finalize Version 1 of our \n \nnew directive. …it('should have sized masonry correctly', function () {\n  var maxElHeight = 0;\n  element('.grid-element').query(function (elements, done) {\n    elements.each(function (idx) {\n      var el = elements.eq(0);\n      var elHeight = el.outerHeight();\n      if (elHeight > maxElHeight) {\n        maxElHeight = elHeight;\n      };     });     done();   });  expect(element('.content-grid').outerHeight())\n    .not().toBeLessThan(maxElHeight)\n})\n[ 92 ]\nThe element().query(fn)  method is provided by the Angular Scenario Runner and \nallows you to execute a function with the selected elements as your first parameter. \nJust be sure to call done() , the second parameter, at the end of your callback \nfunction, as this lets the Scenario Runner know that it can continue its tests. This \ntest's setup still isn't perfect, since if we have several rows of content it might still \npass. Most developers will tell you that it's impossible to perfectly test everything, \nespecially when dealing with the browser directly, but at least this helps ensure that \nour internal compilation has progressed prior to Masonry resetting the layout.\nFurther steps\nWith that, we'll conclude our walkthrough of the development of a directive, \nhowever there are of course several other features and improvements left to add. If \nyou want to experiment on your own, a few starting ideas might include adding the \nability to transclude existing content elements into your grid or even allow certain \nelements to be stamped , which is Masonry's term for gluing one or more elements \nin place and then laying everything else out around them. Finally, if you want to \nexperiment with controllers, try replacing our \nelements  watcher statement with a \ncontroller function that each element directive calls when it initializes and ensure \nthat the initOrUpdateMasonry  method only fires when all the elements are ready. \nIf you're really adventurous, you can even use Masonry's \nappended  and prepended  \nmethods instead of reloadItems  so that Masonry knows exactly how to update \nits layout more appropriately. And of course, if you want to join in on the live \ndevelopment of this or other Angular plugins, the development community \n \nis always open to new contributions. Summary Well, I hope you've enjoyed the ride through this book as much as I've enjoyed \nwriting it, and hopefully I've managed to whet your appetite for even more \nAngularJS and data-driven modularity going forward. Angular is an extremely \nfeature-full framework, and even as I was writing this book I discovered a multitude \nof new capabilities and development paradigms that furthered my coding processes. \nThere are significant areas we haven't even touched. Services, in particular, deserve \na mini-book of their own. I highly encourage you, whether it's with Angular, another \nframework, or a different language entirely, to continue experimenting and diving \ndeeper into the world of problem solving through code. Thanks again for reading. \nYou can find me online at http:\/\/www.mrvdot.com ; please don't hesitate to contact \nme there with any questions or suggestions you might have.\nIndex\nSymbols $watch method   37 & - method binding  44, 46 @ - read-only Access  41-43 = - two-way binding  43, 44 AAngular about  17, 65-67 directives, handling  20 functions, receiving from compile  properties  29, 30 functions, receiving from link  properties  29, 30 Angular content grid about  82 building  82 exploring  82, 84 angular directives   11, 81 Angular.JS application   17 angular.js file  66 angular-mocks file  66 Angular module initializing  19 attachment styles, directives   21 BbeforeEach method  69 BowerURL  66\nCcodeoverview  5 compile function  32 compile phase   29 compile property  23, 24 configuration options about  22 compile  23, 24 controllers  25 link  23priority  22 replace  23 scope  24 templating  23 terminal  23 transclusion  27 content-grid-element directive  85 controller communication\ncreating  53-57 controller property  25 controllers, over messaging\nscenarios  53 conversational directive   14 Ddataloading  9 mocking  70, 71 data driven development (DDD)\nabout  6-9 data, loading  9 HTML, structuring  9\n[ 94 ]\nJavaScript, adding  10 data driven directive   13 declarative directive   11-13 directives about  17, 18 conversational  14 data driven  13 declarative  11-13 deconstructing  17 naming  20 need for  11 overview  15 directives module extending  19 Don't -Repeat-Yourself code  59 EE2E testing about  68-77 scenarios  73, 74 EACM  21 events   89, 90Ffalse value, scope property  38, 39 formwith single input element  50-52 FormController class   50 FormController object   49 form element   49 frontend web development\nmisunderstandings  6 GGitHub   81HHTMLstructuring  9\nIinitial directive  84, 85 initOrUpdateMasonry method  88, 91 initOrUpdate method  88 isolate scope  25, 41 JJavaScript   10 jQuery   10KKarmaabout  65 configuration file  66 installing  65 karma.conf.js file   66 Llink function  29, 32, 33 linking function  36 linking phase   29 link property  23MMasonry connecting  86, 88 testing  88, 89 URL  86 modularity   6, 7Nnegative testing   77, 79 ng-app directive   18 ngModelController function   51 ng-model directive   51 ng-repeat directive about  31 compile function  31, 32 link function  32, 33 ng-switch directive  34, 35 NPM (Node Package Manager)   65\n[ 95 ]\nPpriority function  31 priority option  22 Rreplace property  23 require property  26 SScenario Runner   72 scenarios, E2E testing  73, 74 Scope - {} & - method binding  44, 46 @ - read-only Access  41-43 = - two-way binding  43, 44 scope object   37 scope property false value  38, 39 true value  40 setTimeout method  91 Ttemplate property  23 templateUrl property  23 terminal option  23 Test Driven Development (TDD)   67 testing   65 test subject  71, 72 transclude   59 transcluded content manipulating  62, 63 transclude function  31 transclusion   27, 59, 60, 61 true value, scope property  40 Uunit testing   68, 69 Wweb applications designing  5\n\nThank you for buying  AngularJS Directives\nAbout Packt Publishing\nPackt, pronounced 'packed', published its first book \"\nMastering phpMyAdmin for Effective \nMySQL Management \" in April 2004 and subsequently continued to specialize in publishing \nhighly focused books on specific technologies and solutions.\nOur books and publications share the experiences of your fellow IT professionals in adapting \nand customizing today's systems, applications, and frameworks. Our solution based books \ngive you the knowledge and power to customize the software and technologies you're using \nto get the job done. Packt books are more specific and less general than the IT books you have \nseen in the past. Our unique business model allows us to bring you more focused information, \ngiving you more of what you need to know, and less of what you don't.\nPackt is a modern, yet unique publishing company, which focuses on producing quality, \ncutting-edge books for communities of developers, administrators, and newbies alike. For \nmore information, please visit our website: \nwww.packtpub.com . About Packt Open Source\nIn 2010, Packt launched two new brands, Packt Open Source and Packt Enterprise, in order to \ncontinue its focus on specialization. This book is part of the Packt Open Source brand, home \nto books published on software built around Open Source licences, and offering information \nto anybody from advanced developers to budding web designers. The Open Source brand \nalso runs Packt's Open Source Royalty Scheme, by which Packt gives a royalty to each Open \nSource project about whose software a book is sold.\nWriting for Packt\nWe welcome all inquiries from people who are interested in authoring. Book proposals \nshould be sent to author@packtpub.com. If your book idea is still at an early stage and you \nwould like to discuss it first before writing a formal book proposal, contact us; one of our \ncommissioning editors will get in touch with you. \nWe're not just looking for published authors; if you have strong technical skills but no writing \nexperience, our experienced editors can help you develop a writing career, or simply get some \nadditional reward for your expertise.\nInstant AngularJS Starter\nISBN: 978-1-782166-76-4             Paperback: 66 pages\nA concise guide to start building dynamic web \napplications with AngularJS, one of the Web's most \ninnovative JavaScript frameworks\n1. Learn something new in an Instant! A short, \nfast, focused guide delivering immediate \nresults. 2. Take a broad look at the capabilities of \nAngularJS, with in-depth analysis of its key \nfeatures 3. See how to build a structured MVC-style \napplication that will scale gracefully in real-\nworld applications Mastering Web Application \nDevelopment with AngularJS: \nRAWISBN: 978-1-782161-82-0            Paperback: 402 pages\nBuild single-page web applications using the power \nof the AngularJS JavaScript framework from Google\n1. Make the most out of AngularJS by \nunderstanding the AngularJS philosophy and \napplying it to real life development tasks\n2. Effectively structure, write, test, and finally \ndeploy your application \n3. Add security and optimization features to your \nAngularJS applications\n4. Harness the full power of AngularJS by \ncreating your own directives\nPlease check www.PacktPub.com  for information on our titles\nExt JS 4 Web Application \nDevelopment Cookbook\nISBN: 978-1-849516-86-0            Paperback: 488 pages\nOver 110 easy-to-follow recipes backed up with \nreal-life examples, walking you through basic Ext \nJS features to advanced application design using \nSencha's Ext JS 1. Learn how to build Rich Internet Applications \nwith the latest version of the Ext JS framework \nin a cookbook style\n2. From creating forms to theming your \ninterface, you will learn the building blocks for \ndeveloping the perfect web application\n3. Easy to follow recipes step through practical \nand detailed examples which are all fully \nbacked up with code, illustrations, and tips \nExt JS 4 First Look\nISBN: 978-1-849516-66-2            Paperback: 340 pages\nA practical guide including examples of the new \nfeatures in Ext JS 4 and tips to migrate from Ext JS 3\n1. Migrate your Ext JS 3 applications easily to \n Ext JS 4 based on the examples presented in \n this guide 2. Full of diagrams, illustrations, and step-by-step \ninstructions to develop real word applications\n4. Driven by examples and explanations of how \nthings work\nPlease check www.PacktPub.com  for information on our titles\n","FILENAME":"AngularJS_Directives_Pub2013_Edition1.pdf","FILETYPE":".pdf","META-INFORMATION":{"ATTACHMENT & EMBEDDING":"","AUTHOR":"","CREATED":"D:20130902131109+05'30'","DATE EDITED":"D:20130902131648+05'30'","KEYWORDS":"","REVIEW & COMMENTING":"","SUBJECT":"","TITLE":"","XMP":"<?xpacket begin=\"﻿\" id=\"W5M0MpCehiHzreSzNTczkc9d\"?>\n<x:xmpmeta xmlns:x=\"adobe:ns:meta\/\" x:xmptk=\"Adobe XMP Core 5.2-c001 63.139439, 2010\/09\/27-13:37:26        \">\n   <rdf:RDF xmlns:rdf=\"http:\/\/www.w3.org\/1999\/02\/22-rdf-syntax-ns#\">\n      <rdf:Description rdf:about=\"\"\n            xmlns:xmpMM=\"http:\/\/ns.adobe.com\/xap\/1.0\/mm\/\"\n            xmlns:stRef=\"http:\/\/ns.adobe.com\/xap\/1.0\/sType\/ResourceRef#\"\n            xmlns:stEvt=\"http:\/\/ns.adobe.com\/xap\/1.0\/sType\/ResourceEvent#\">\n         <xmpMM:InstanceID>uuid:382441ed-5416-4771-aa19-e32033d2b926<\/xmpMM:InstanceID>\n         <xmpMM:OriginalDocumentID>adobe:docid:indd:4992da54-27df-11de-a18e-f5498a2a904f<\/xmpMM:OriginalDocumentID>\n         <xmpMM:DocumentID>xmp.did:049CF59C3406E31186ACC69F41C4CDB9<\/xmpMM:DocumentID>\n         <xmpMM:RenditionClass>proof:pdf<\/xmpMM:RenditionClass>\n         <xmpMM:DerivedFrom rdf:parseType=\"Resource\">\n            <stRef:instanceID>713ec90e-27db-11de-a18e-f5498a2a904f<\/stRef:instanceID>\n            <stRef:documentID>adobe:docid:indd:08d06915-e4d3-11da-8821-8147fa8cbb52<\/stRef:documentID>\n         <\/xmpMM:DerivedFrom>\n         <xmpMM:History>\n            <rdf:Seq>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:6A1AF379F4A3E111B5AF96FBD560C3DD<\/stEvt:instanceID>\n                  <stEvt:when>2012-05-22T15:54:29+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.0<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/;\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:6B1AF379F4A3E111B5AF96FBD560C3DD<\/stEvt:instanceID>\n                  <stEvt:when>2012-05-22T15:54:29+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.0<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:C408380B1BA6E1119CBDAF783C44C647<\/stEvt:instanceID>\n                  <stEvt:when>2012-05-25T09:12:28+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.0<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/;\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:C508380B1BA6E1119CBDAF783C44C647<\/stEvt:instanceID>\n                  <stEvt:when>2012-05-25T09:12:28+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.0<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:007D27201CA6E1119CBDAF783C44C647<\/stEvt:instanceID>\n                  <stEvt:when>2012-05-25T09:15:52+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.0<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/;\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:017D27201CA6E1119CBDAF783C44C647<\/stEvt:instanceID>\n                  <stEvt:when>2012-05-25T09:16:24+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.0<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/;\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:45048A4FA2A8E111AC02958474B072BE<\/stEvt:instanceID>\n                  <stEvt:when>2012-05-28T14:51:19+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.0<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/;\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:8C7F6616A8A8E111AC02958474B072BE<\/stEvt:instanceID>\n                  <stEvt:when>2012-05-28T15:07:38+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.0<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/;\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:42195515ABA8E111AC02958474B072BE<\/stEvt:instanceID>\n                  <stEvt:when>2012-05-28T15:29:29+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.0<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/;\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:05D0CA20ACA8E111AC02958474B072BE<\/stEvt:instanceID>\n                  <stEvt:when>2012-05-28T15:42:40+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.0<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/;\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:C664CDA7B6AFE1118EF4B4604D8FED7A<\/stEvt:instanceID>\n                  <stEvt:when>2012-06-06T14:35:49+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.0<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/;\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:F9565F9082C9E111B9EBEA018E6F1527<\/stEvt:instanceID>\n                  <stEvt:when>2012-07-09T10:32:51+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.0<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/;\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:21F26CD93906E31186ACC69F41C4CDB9<\/stEvt:instanceID>\n                  <stEvt:when>2013-08-16T11:35:28+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.5<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/;\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:22F26CD93906E31186ACC69F41C4CDB9<\/stEvt:instanceID>\n                  <stEvt:when>2013-08-16T11:35:28+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.5<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:25F26CD93906E31186ACC69F41C4CDB9<\/stEvt:instanceID>\n                  <stEvt:when>2013-08-16T11:41:53+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.5<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/;\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:28F26CD93906E31186ACC69F41C4CDB9<\/stEvt:instanceID>\n                  <stEvt:when>2013-08-16T11:42:09+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.5<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/;\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:11B757012C07E311807EB67D93673F81<\/stEvt:instanceID>\n                  <stEvt:when>2013-08-17T16:32:05+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.5<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/;\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:14B757012C07E311807EB67D93673F81<\/stEvt:instanceID>\n                  <stEvt:when>2013-08-17T16:33:44+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.5<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/;\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:D850FDD66409E3119D33CE4E329FEBFA<\/stEvt:instanceID>\n                  <stEvt:when>2013-08-20T12:20:45+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.5<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/;\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:DB50FDD66409E3119D33CE4E329FEBFA<\/stEvt:instanceID>\n                  <stEvt:when>2013-08-20T12:21:39+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.5<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/;\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:DE50FDD66409E3119D33CE4E329FEBFA<\/stEvt:instanceID>\n                  <stEvt:when>2013-08-20T12:22:12+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.5<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/;\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:20F8A8637309E3119D33CE4E329FEBFA<\/stEvt:instanceID>\n                  <stEvt:when>2013-08-20T14:05:55+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.5<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/;\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:CE26FD3B9309E3119D33CE4E329FEBFA<\/stEvt:instanceID>\n                  <stEvt:when>2013-08-20T17:55:24+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.5<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/;\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:6D83EA9E9309E3119D33CE4E329FEBFA<\/stEvt:instanceID>\n                  <stEvt:when>2013-08-20T17:55:38+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.5<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/;\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:7083EA9E9309E3119D33CE4E329FEBFA<\/stEvt:instanceID>\n                  <stEvt:when>2013-08-20T17:55:44+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.5<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/;\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:7383EA9E9309E3119D33CE4E329FEBFA<\/stEvt:instanceID>\n                  <stEvt:when>2013-08-20T17:56:01+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.5<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/;\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:DDD799739509E3119D33CE4E329FEBFA<\/stEvt:instanceID>\n                  <stEvt:when>2013-08-20T18:10:32+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.5<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/;\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:BF664BA89809E3119D33CE4E329FEBFA<\/stEvt:instanceID>\n                  <stEvt:when>2013-08-20T18:52:01+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.5<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/;\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:C2664BA89809E3119D33CE4E329FEBFA<\/stEvt:instanceID>\n                  <stEvt:when>2013-08-20T18:52:10+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.5<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/;\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:E2169D469C09E3119D33CE4E329FEBFA<\/stEvt:instanceID>\n                  <stEvt:when>2013-08-20T18:57:35+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.5<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/;\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:E5169D469C09E3119D33CE4E329FEBFA<\/stEvt:instanceID>\n                  <stEvt:when>2013-08-20T18:58:49+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.5<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/;\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:E8169D469C09E3119D33CE4E329FEBFA<\/stEvt:instanceID>\n                  <stEvt:when>2013-08-20T18:59:52+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.5<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/;\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <stEvt:action>saved<\/stEvt:action>\n                  <stEvt:instanceID>xmp.iid:30B083C4A213E311B488D685DBB23F3C<\/stEvt:instanceID>\n                  <stEvt:when>2013-09-02T13:09:15+05:30<\/stEvt:when>\n                  <stEvt:softwareAgent>Adobe InDesign 7.5<\/stEvt:softwareAgent>\n                  <stEvt:changed>\/;\/metadata<\/stEvt:changed>\n               <\/rdf:li>\n            <\/rdf:Seq>\n         <\/xmpMM:History>\n      <\/rdf:Description>\n      <rdf:Description rdf:about=\"\"\n            xmlns:xmp=\"http:\/\/ns.adobe.com\/xap\/1.0\/\"\n            xmlns:xmpTPg=\"http:\/\/ns.adobe.com\/xap\/1.0\/t\/pg\/\"\n            xmlns:xmpGImg=\"http:\/\/ns.adobe.com\/xap\/1.0\/g\/img\/\">\n         <xmp:CreateDate>2013-09-02T13:11:09+05:30<\/xmp:CreateDate>\n         <xmp:ModifyDate>2013-09-02T13:16:48+05:30<\/xmp:ModifyDate>\n         <xmp:MetadataDate>2013-09-02T13:16:48+05:30<\/xmp:MetadataDate>\n         <xmp:CreatorTool>Adobe InDesign CS5.5 (7.5)<\/xmp:CreatorTool>\n         <xmp:PageInfo>\n            <rdf:Seq>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <xmpTPg:PageNumber>1<\/xmpTPg:PageNumber>\n                  <xmpGImg:format>JPEG<\/xmpGImg:format>\n                  <xmpGImg:width>256<\/xmpGImg:width>\n                  <xmpGImg:height>256<\/xmpGImg:height>\n                  <xmpGImg:image>\/9j\/4AAQSkZJRgABAgEASABIAAD\/7QAsUGhvdG9zaG9wIDMuMAA4QklNA+0AAAAAABAASAAAAAEA&#xA;AQBIAAAAAQAB\/+4AE0Fkb2JlAGSAAAAAAQUAAgAg\/9sAhAAKBwcHBwcKBwcKDgkJCQ4RDAsLDBEU&#xA;EBAQEBAUEQ8RERERDxERFxoaGhcRHyEhISEfKy0tLSsyMjIyMjIyMjIyAQsJCQ4MDh8XFx8rIh0i&#xA;KzIrKysrMjIyMjIyMjIyMjIyMjIyMjI+Pj4+PjJAQEBAQEBAQEBAQEBAQEBAQEBAQED\/wAARCAEA&#xA;AMYDAREAAhEBAxEB\/8QBogAAAAcBAQEBAQAAAAAAAAAABAUDAgYBAAcICQoLAQACAgMBAQEBAQAA&#xA;AAAAAAABAAIDBAUGBwgJCgsQAAIBAwMCBAIGBwMEAgYCcwECAxEEAAUhEjFBUQYTYSJxgRQykaEH&#xA;FbFCI8FS0eEzFmLwJHKC8SVDNFOSorJjc8I1RCeTo7M2F1RkdMPS4ggmgwkKGBmElEVGpLRW01Uo&#xA;GvLj88TU5PRldYWVpbXF1eX1ZnaGlqa2xtbm9jdHV2d3h5ent8fX5\/c4SFhoeIiYqLjI2Oj4KTlJ&#xA;WWl5iZmpucnZ6fkqOkpaanqKmqq6ytrq+hEAAgIBAgMFBQQFBgQIAwNtAQACEQMEIRIxQQVRE2Ei&#xA;BnGBkTKhsfAUwdHhI0IVUmJy8TMkNEOCFpJTJaJjssIHc9I14kSDF1STCAkKGBkmNkUaJ2R0VTfy&#xA;o7PDKCnT4\/OElKS0xNTk9GV1hZWltcXV5fVGVmZ2hpamtsbW5vZHV2d3h5ent8fX5\/c4SFhoeIiY&#xA;qLjI2Oj4OUlZaXmJmam5ydnp+So6SlpqeoqaqrrK2ur6\/9oADAMBAAIRAxEAPwCbeU\/KflW58q6L&#xA;cXGi6fNNNp9rJJJJaws7u0MbMzM0ZJJJ3OKpt\/gzyf8A9WHTf+kOD\/qnirv8GeT\/APqw6b\/0hwf9&#xA;U8Vd\/gzyf\/1YdN\/6Q4P+qeKu\/wAGeT\/+rDpv\/SHB\/wBU8Vd\/gzyf\/wBWHTf+kOD\/AKp4q7\/Bnk\/\/&#xA;AKsOm\/8ASHB\/1TxV3+DPJ\/8A1YdN\/wCkOD\/qnirv8GeT\/wDqw6b\/ANIcH\/VPFXf4M8n\/APVh03\/p&#xA;Dg\/6p4q7\/Bnk\/wD6sOm\/9IcH\/VPFXf4M8n\/9WHTf+kOD\/qnirv8ABnk\/\/qw6b\/0hwf8AVPFXf4M8&#xA;n\/8AVh03\/pDg\/wCqeKu\/wZ5P\/wCrDpv\/AEhwf9U8Vd\/gzyf\/ANWHTf8ApDg\/6p4q7\/Bnk\/8A6sOm&#xA;\/wDSHB\/1TxV3+DPJ\/wD1YdN\/6Q4P+qeKu\/wZ5P8A+rDpv\/SHB\/1TxV3+DPJ\/\/Vh03\/pDg\/6p4q7\/&#xA;AAZ5P\/6sOm\/9IcH\/AFTxV3+DPJ\/\/AFYdN\/6Q4P8Aqnirv8GeT\/8Aqw6b\/wBIcH\/VPFXf4M8n\/wDV&#xA;h03\/AKQ4P+qeKpTrPlPyrFqOgJFounok+oSRyqtrCA6Cwv5OLgR7jkimh7gYqm3kz\/lD9B\/7Ztn\/&#xA;AMmI8VTrFXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FUl13\/jqeXP8A&#xA;tpSf907UsVd5M\/5Q\/Qf+2bZ\/8mI8VTrFXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7&#xA;FXYq7FXYq7FUl13\/AI6nlz\/tpSf907UsVd5M\/wCUP0H\/ALZtn\/yYjxVOsVdirsVdirsVdirsVdir&#xA;sVdirsVdirsVdirsVdirsVdirsVdirsVdirsVSXXf+Op5c\/7aUn\/AHTtSxV3kz\/lD9B\/7Ztn\/wAm&#xA;I8VTrFXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FUl13\/jqeXP+2lJ\/&#xA;3TtSxV3kz\/lD9B\/7Ztn\/AMmI8VTrFXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXY&#xA;q7FXYq7FUl13\/jqeXP8AtpSf907UsVd5M\/5Q\/Qf+2bZ\/8mI8VTrFXYq7FVOWeGHh60ix+qwjj5sF&#xA;5OeirXqTTpiqpirsVWpIkqh42DoejKQQfpGKtPNDEyJJIqNKSEDEAsQC5C160VScVULPU9N1FJJN&#xA;Pu4LtIGMcrQSJIEYblXKMaH2OKqVnruiaijyafqNpdpEVWRoJ45Apc8VDFGNKnpiqPxVZJLFCpeZ&#xA;1jUAks5AFACx3PgBXFVwIIBBqDuCMVbxV2KuxV2KuxV2KuxV2KuxV2KpLrv\/AB1PLn\/bSk\/7p2pY&#xA;q7yZ\/wAofoP\/AGzbP\/kxHiqdYq7FXYqxrzRour63cQpYyQW0VjGZ4nuYfXDXXIGJowtxCyPF6ezG&#xA;o+LviqC1C21m1t7jWZZLq2MnqtcxNdMyRwViZURFlaNGpzAdenUmmKqGkzazd2f1jTEvLmzu3aO3&#xA;d7tJTAiSo3J5nuG5goCoaNnr4kfFiq650vzN9dtvqcE8KWyMHkS6YRyK4mHH0hepGHVnBqYW2\/aB&#xA;FMVR7afqbSWVgbGWeCySWZrq5uvUWd5reWJoXdnkmVjJKeilQvQ\/s4qiNEtdRVrw3FtNBEYY4IRe&#xA;G1af92HHBZLNm5RDl8PqHlUtiqX2djrk9vpn+4+bTZtMtYrWR5ZYOcv7y05hDbTy\/u+MLE8iD7Yq&#xA;hk0bzdDdaU6XNz6Ijha7rK1wyXAY\/WDJz1G3QoycVA4SgbkKDuVVq6N5ieKCSaC+N5byMZZGvgUe&#xA;4e2u4nubdPrB4RGR04oWFB0Rd+Sq+90vzg4vobZ7gRW9DaP9YLNcJcyrPcIAt1bOGiC8E5SJQGis&#xA;BiqtZ2HmiHUNGnna6uVjjKXglYRQxqWlpySLVZeUioyr8ST1oDyU1OKsyxV2KuxV2KuxV2KuxV2K&#xA;uxVJdd\/46nlz\/tpSf907UsVd5M\/5Q\/Qf+2bZ\/wDJiPFU6xV2KuxV2KuxV2KuxV2KuxV2KuxV2Kux&#xA;V2KuxV2KuxV2KuxV2KuxV2KuxVJdd\/46nlz\/ALaUn\/dO1LFXeTP+UP0H\/tm2f\/JiPFU6xV2KuxV2&#xA;KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxVJdd\/wCOp5c\/7aUn\/dO1LFXeTP8A&#xA;lD9B\/wC2bZ\/8mI8VTrFXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FUl&#xA;13\/jqeXP+2lJ\/wB07UsVd5M\/5Q\/Qf+2bZ\/8AJiPFU6xV2KuxVJNX82aVol0LO99X1CgkHBQwoSR\/&#xA;MPDFUD\/ysTy\/4T\/8ix\/zXirv+VieX\/Cf\/kWP+a8Vd\/ysTy\/4T\/8AIsf814q7\/lYnl\/wn\/wCRY\/5r&#xA;xV3\/ACsTy\/4T\/wDIsf8ANeKu\/wCVieX\/AAn\/AORY\/wCa8Vd\/ysTy\/wCE\/wDyLH\/NeKu\/5WJ5f8J\/&#xA;+RY\/5rxV3\/KxPL\/hP\/yLH\/NeKu\/5WJ5f8J\/+RY\/5rxV3\/KxPL\/hP\/wAix\/zXirv+VieX\/Cf\/AJFj&#xA;\/mvFXf8AKxPL\/hP\/AMix\/wA14qmOjeaNM12eSCx9TnEvNvUUKKVp\/MfHFU4xV2KuxV2KuxVJdd\/4&#xA;6nlz\/tpSf907UsVd5M\/5Q\/Qf+2bZ\/wDJiPFU6xV2KuxVhvmy\/W21NYzokWp\/ulPrvGWI3b4KhW6Y&#xA;qkn6YX\/qVYP+RLf9U8Vd+mF\/6lWD\/kS3\/VPFXfphf+pVg\/5Et\/1TxV36YX\/qVYP+RLf9U8Vd+mF\/&#xA;6lWD\/kS3\/VPFXfphf+pVg\/5Et\/1TxV36YX\/qVYP+RLf9U8Vd+mF\/6lWD\/kS3\/VPFXfphf+pVg\/5E&#xA;t\/1TxV36YX\/qVYP+RLf9U8Vd+mF\/6lWD\/kS3\/VPFXfphf+pVg\/5Et\/1TxVO\/LUen609wt7oNvZiE&#xA;IUJi+1y5V+0o6UxVk9ppWm2DtJZWsVu7jizRoFJHWhpiqLxV2KuxV2KuxVJdd\/46nlz\/ALaUn\/dO&#xA;1LFXeTP+UP0H\/tm2f\/JiPFU6xV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV&#xA;2KuxVJdd\/wCOp5c\/7aUn\/dO1LFXeTP8AlD9B\/wC2bZ\/8mI8VTrFXYq7FXYq7FXYq7FXYq7FXYq7F&#xA;XYq7FXYq7FXYq7FXYq7FXYq7FXYq7FUl13\/jqeXP+2lJ\/wB07UsVd5M\/5Q\/Qf+2bZ\/8AJiPFU6xV&#xA;2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxVJdd\/46nlz\/tpSf907UsVd&#xA;5M\/5Q\/Qf+2bZ\/wDJiPFU6xV2KuxVSkuLeJuMsqI3WjMAafScVW\/XbP8A5aIv+DX+uKu+u2f\/AC0R&#xA;f8Gv9cVbF5aE0E8ZJ6Dmv9cVVsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdiqS67\/wAdTy5\/&#xA;20pP+6dqWKu8mf8AKH6D\/wBs2z\/5MR4qnWKuxV2KpDrXk\/TNdvBe3cs6SKgjpEyBaKSf2o2\/mxVL&#xA;\/wDlW2hf7\/u\/+Dj\/AOqOKu\/5VtoX+\/7v\/g4\/+qOKr4Py70WCaOdJ7otEyuoLx0qprv8AucVZXirs&#xA;VdirsVdirsVdirsVdirsVdirsVdirsVdirsVSXXf+Op5c\/7aUn\/dO1LFXeTP+UP0H\/tm2f8AyYjx&#xA;VOsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVSXXf+Op5c\/wC2lJ\/3&#xA;TtSxV3kz\/lD9B\/7Ztn\/yYjxVOsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirs&#xA;VdirsVSXXf8AjqeXP+2lJ\/3TtSxV3kz\/AJQ\/Qf8Atm2f\/JiPFU6xV2KuxV2KuxV2KuxV2KuxV2Ku&#xA;xV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxVJdd\/46nlz\/tpSf8AdO1LFXeTP+UP0H\/tm2f\/ACYjxVOs&#xA;VdirsVQS6hz1aXSliNYLeK5klJFKTPPGigdf90NXFVeG7tbkkW8ySkCpCMGoD8jlcM0Mn0kFnPFO&#xA;HMUuW4gaIzrIhiAJMgYcQF6\/F02pkhkiY8V7d6DCQlVbuSeGTj6citzrxoRvTrTGOSMuRUwkOYU2&#xA;v7FOPO4iXmKrVwKj23yB1GIc5BkMGQ8gVP8ASFNUXTWiI9SBriOUMCCEaNGBHUGsgy1rVWvrNA7P&#xA;PGqxV5ksAFoeBqa9m2+eKtm7tQvMyoFLcK1H2gOXH503xVwu7VpFiWZDI4BVQwJIILCnzCk\/RirZ&#xA;ubZWdGlQGIFpAWA4gAMS3hQMD9OKtpcQSAmORW4kg0I2IAJr9BxVZ9dtPiAnjPBuDUYGjkcuPzpv&#xA;TFWxd2zMqLKjO4BRQwJaoLCm\/dRXFULb3c7zj1CtJSV9IHePiP8AUFalW7\/LMXFmmZb9end9jkZM&#xA;URHbp17\/ALUwzKcd2KuxV2KuxV2KpLrv\/HU8uf8AbSk\/7p2pYq7yZ\/yh+g\/9s2z\/AOTEeKp1irsV&#xA;diqT2\/8Aylmo\/wDbOsP+T2pYqst0mi0y1vA6mRLYQQKFI+KYxKnI8jWhAzXY4yjgjO9+Gh8ac7IY&#xA;yyyjW3FZ+FrWR7JWs2oYYpLaf4QaCIMFfb\/JaPkfngMTiBh0Bifh1+60iQyHi6kSHx\/BV9RJvWg+&#xA;oSo\/JZRVDUNQLVA6navSvbLNSTlMeA97XgHhg8Y7lVpYphpskA4p6xASlCtIZ1KkdiKUyZnGfhkc&#xA;uL\/eyYiJjxg936QpS1\/xTa77fo+52719a0zLcZuazbgsYnokBjWECIkqokic8m+Lkf3VB0964quk&#xA;tGmBc3FLlXqXVJEj+JVXjwSRW6KP2+vttiqvHHbwBVQsFiIKrxY7KnpUG2+KqbwK9xJL6hjWReix&#xA;src6LRmb7LU4ClVr2rTbFWninaMn6wBcSblxC3AKy8aCPnUeO7dfbbFVQQH01S1l4SxSOwaSMspL&#xA;cuQK1Sv2uob+mKtLpoF41yZCySMsrxty\/vFVEUrSQIB8ANOJ374qilt4Ff1FjUPUnkAK1PU5AY4A&#xA;3TIzkRVqmTYuxV2KuxV2KuxVJdd\/46nlz\/tpSf8AdO1LFXeTP+UP0H\/tm2f\/ACYjxVOsVdirsVQ3&#xA;1G3W+fUkDC6khSBm5NxZI2kdAUrx2Mrb074quka6VW4KHYREqRTeQdBQsP8APviq9GlJIdaUpuKU&#xA;NRvTeuxxVYrXRVeSKDQ8vn8VNgT7d8Vc7XS+oURXpT0wDQmta8q\/Riq0WNv9e\/SNGNx6ZhBLsVCM&#xA;VZgqV4ipQdsVROKuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxVJdd\/46nlz\/tpSf8AdO1LFXeTP+UP&#xA;0H\/tm2f\/ACYjxVOsVdirsVSfVbLzFcXIk0rUksoOABiaFJDyqatyZTiqC\/RXnT\/q+Rf9I0f\/ADRi&#xA;rv0V50\/6vkX\/AEjR\/wDNGKu\/RXnT\/q+Rf9I0f\/NGKu\/RXnT\/AKvkX\/SNH\/zRiq+DTPN6TxvPrMck&#xA;SupkQW8YLKD8S1CbVGKsixV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KpLrv\/AB1PLn\/bSk\/7p2pY&#xA;q7yZ\/wAofoP\/AGzbP\/kxHiqdYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq&#xA;7FXYqkuu\/wDHU8uf9tKT\/unalirvJn\/KH6D\/ANs2z\/5MR4qnWKuxV2KuxV2KuxV2KuxV2KuxV2Ku&#xA;xV2KuxV2KuxV2KuxV2KuxV2KuxV2KpLrv\/HU8uf9tKT\/ALp2pYq7yZ\/yh+g\/9s2z\/wCTEeKp1irs&#xA;VdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdiqS67\/x1PLn\/AG0pP+6dqWKu&#xA;8mf8ofoP\/bNs\/wDkxHiqdYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FX&#xA;Yqkuu\/8AHU8uf9tKT\/unalirvJn\/ACh+g\/8AbNs\/+TEeKp1irsVdirsVdirsVdirsVdirsVdirsV&#xA;dirsVdirsVdirsVdirsVdirsVdiqS67\/AMdTy5\/20pP+6dqWKu8mf8ofoP8A2zbP\/kxHiqdYq7FX&#xA;Yq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYqkuu\/8dTy5\/20pP8AunaliqU+&#xA;U\/NnlW28q6Lb3GtafDNDp9rHJHJdQq6OsMasrK0gIII3GKpt\/jPyf\/1ftN\/6TIP+qmKu\/wAZ+T\/+&#xA;r9pv\/SZB\/wBVMVd\/jPyf\/wBX7Tf+kyD\/AKqYq7\/Gfk\/\/AKv2m\/8ASZB\/1UxV3+M\/J\/8A1ftN\/wCk&#xA;yD\/qpirv8Z+T\/wDq\/ab\/ANJkH\/VTFXf4z8n\/APV+03\/pMg\/6qYq7\/Gfk\/wD6v2m\/9JkH\/VTFXf4z&#xA;8n\/9X7Tf+kyD\/qpirv8AGfk\/\/q\/ab\/0mQf8AVTFXf4z8n\/8AV+03\/pMg\/wCqmKu\/xn5P\/wCr9pv\/&#xA;AEmQf9VMVd\/jPyf\/ANX7Tf8ApMg\/6qYq7\/Gfk\/8A6v2m\/wDSZB\/1UxV3+M\/J\/wD1ftN\/6TIP+qmK&#xA;u\/xn5P8A+r9pv\/SZB\/1UxV3+M\/J\/\/V+03\/pMg\/6qYq7\/ABn5P\/6v2m\/9JkH\/AFUxV3+M\/J\/\/AFft&#xA;N\/6TIP8Aqpirv8Z+T\/8Aq\/ab\/wBJkH\/VTFXf4z8n\/wDV+03\/AKTIP+qmKu\/xn5P\/AOr9pv8A0mQf&#xA;9VMVd\/jPyf8A9X7Tf+kyD\/qpiqU6z5s8qy6joDxa1p7pBqEkkrLdQkIhsL+Pk5Emw5Ooqe5GKv8A&#xA;\/9k=<\/xmpGImg:image>\n               <\/rdf:li>\n               <rdf:li rdf:parseType=\"Resource\">\n                  <xmpTPg:PageNumber>2<\/xmpTPg:PageNumber>\n                  <xmpGImg:format>JPEG<\/xmpGImg:format>\n                  <xmpGImg:width>256<\/xmpGImg:width>\n                  <xmpGImg:height>256<\/xmpGImg:height>\n                  <xmpGImg:image>\/9j\/4AAQSkZJRgABAgEASABIAAD\/7QAsUGhvdG9zaG9wIDMuMAA4QklNA+0AAAAAABAASAAAAAEA&#xA;AQBIAAAAAQAB\/+4AE0Fkb2JlAGSAAAAAAQUAAgAg\/9sAhAAKBwcHBwcKBwcKDgkJCQ4RDAsLDBEU&#xA;EBAQEBAUEQ8RERERDxERFxoaGhcRHyEhISEfKy0tLSsyMjIyMjIyMjIyAQsJCQ4MDh8XFx8rIh0i&#xA;KzIrKysrMjIyMjIyMjIyMjIyMjIyMjI+Pj4+PjJAQEBAQEBAQEBAQEBAQEBAQEBAQED\/wAARCAEA&#xA;AMYDAREAAhEBAxEB\/8QBogAAAAcBAQEBAQAAAAAAAAAABAUDAgYBAAcICQoLAQACAgMBAQEBAQAA&#xA;AAAAAAABAAIDBAUGBwgJCgsQAAIBAwMCBAIGBwMEAgYCcwECAxEEAAUhEjFBUQYTYSJxgRQykaEH&#xA;FbFCI8FS0eEzFmLwJHKC8SVDNFOSorJjc8I1RCeTo7M2F1RkdMPS4ggmgwkKGBmElEVGpLRW01Uo&#xA;GvLj88TU5PRldYWVpbXF1eX1ZnaGlqa2xtbm9jdHV2d3h5ent8fX5\/c4SFhoeIiYqLjI2Oj4KTlJ&#xA;WWl5iZmpucnZ6fkqOkpaanqKmqq6ytrq+hEAAgIBAgMFBQQFBgQIAwNtAQACEQMEIRIxQQVRE2Ei&#xA;BnGBkTKhsfAUwdHhI0IVUmJy8TMkNEOCFpJTJaJjssIHc9I14kSDF1STCAkKGBkmNkUaJ2R0VTfy&#xA;o7PDKCnT4\/OElKS0xNTk9GV1hZWltcXV5fVGVmZ2hpamtsbW5vZHV2d3h5ent8fX5\/c4SFhoeIiY&#xA;qLjI2Oj4OUlZaXmJmam5ydnp+So6SlpqeoqaqrrK2ur6\/9oADAMBAAIRAxEAPwCbeU\/KflW58q6L&#xA;cXGi6fNNNp9rJJJJaws7u0MbMzM0ZJJJ3OKpt\/gzyf8A9WHTf+kOD\/qnirv8GeT\/APqw6b\/0hwf9&#xA;U8Vd\/gzyf\/1YdN\/6Q4P+qeKu\/wAGeT\/+rDpv\/SHB\/wBU8Vd\/gzyf\/wBWHTf+kOD\/AKp4q7\/Bnk\/\/&#xA;AKsOm\/8ASHB\/1TxV3+DPJ\/8A1YdN\/wCkOD\/qnirv8GeT\/wDqw6b\/ANIcH\/VPFXf4M8n\/APVh03\/p&#xA;Dg\/6p4q7\/Bnk\/wD6sOm\/9IcH\/VPFXf4M8n\/9WHTf+kOD\/qnirv8ABnk\/\/qw6b\/0hwf8AVPFXf4M8&#xA;n\/8AVh03\/pDg\/wCqeKu\/wZ5P\/wCrDpv\/AEhwf9U8Vd\/gzyf\/ANWHTf8ApDg\/6p4q7\/Bnk\/8A6sOm&#xA;\/wDSHB\/1TxV3+DPJ\/wD1YdN\/6Q4P+qeKu\/wZ5P8A+rDpv\/SHB\/1TxV3+DPJ\/\/Vh03\/pDg\/6p4q7\/&#xA;AAZ5P\/6sOm\/9IcH\/AFTxV3+DPJ\/\/AFYdN\/6Q4P8Aqnirv8GeT\/8Aqw6b\/wBIcH\/VPFXf4M8n\/wDV&#xA;h03\/AKQ4P+qeKpTrPlPyrFqOgJFounok+oSRyqtrCA6Cwv5OLgR7jkimh7gYqm3kz\/lD9B\/7Ztn\/&#xA;AMmI8VTrFXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FUl13\/jqeXP8A&#xA;tpSf907UsVd5M\/5Q\/Qf+2bZ\/8mI8VTrFXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7&#xA;FXYq7FXYq7FUl13\/AI6nlz\/tpSf907UsVd5M\/wCUP0H\/ALZtn\/yYjxVOsVdirsVdirsVdirsVdir&#xA;sVdirsVdirsVdirsVdirsVdirsVdirsVdirsVSXXf+Op5c\/7aUn\/AHTtSxV3kz\/lD9B\/7Ztn\/wAm&#xA;I8VTrFXYq7FUp1PzPo2j3Atb+YxylQ4UI7fCSQN1U+GKoP8Ax35Z\/wCWpv8AkVJ\/zRirv8d+Wf8A&#xA;lqb\/AJFSf80Yq7\/Hfln\/AJam\/wCRUn\/NGKu\/x35Z\/wCWpv8AkVJ\/zRirv8d+Wf8Alqb\/AJFSf80Y&#xA;qmul6tY6zbtdafIZIkcxklSvxAK1KMB2YYqjcVdirsVdirsVdirsVdirsVdirsVdirsVSXXf+Op5&#xA;c\/7aUn\/dO1LFXeTP+UP0H\/tm2f8AyYjxVOsVdirsVS6\/0DR9TmFxf2qzyhQgZiwPEVIGxHjiqG\/w&#xA;f5a\/5YI\/vf8A5qxV3+D\/AC1\/ywR\/e\/8AzVirv8H+Wv8Algj+9\/8AmrFXf4P8tf8ALBH97\/8ANWKu&#xA;\/wAH+Wv+WCP73\/5qxVMLDTbHS4Wt7CEQRMxcqtSCxAWu5PZRiqKxV2KuxV2KuxV2KuxV2KuxV2Ku&#xA;xV2KuxVJdd\/46nlz\/tpSf907UsVd5M\/5Q\/Qf+2bZ\/wDJiPFU6xV2KuxVJdX1XW7K6EOn6U19CUDG&#xA;USBaMSarTifDFUD\/AIh80\/8AUvN\/yOH\/ADTirv8AEPmn\/qXm\/wCRw\/5pxV3+IfNP\/UvN\/wAjh\/zT&#xA;irv8Q+af+peb\/kcP+acVd\/iHzT\/1Lzf8jh\/zTiraeYPM7OqtoDKpIBb1RsPH7OKsnxV2KuxV2Kux&#xA;V2KuxV2KuxV2KuxV2KuxVJdd\/wCOp5c\/7aUn\/dO1LFXeTP8AlD9B\/wC2bZ\/8mI8VTrFXYq7FXYq7&#xA;FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FUl13\/jqeXP+2lJ\/wB07UsVd5M\/5Q\/Q&#xA;f+2bZ\/8AJiPFU6xV2KuxVh3mrU\/qeprF+mptNrErejHb+qDUt8XLmvWmKpN+nf8Av6Ln\/pD\/AOvu&#xA;Ku\/Tv\/f0XP8A0h\/9fcVd+nf+\/ouf+kP\/AK+4q79O\/wDf0XP\/AEh\/9fcVd+nf+\/ouf+kP\/r7irv07&#xA;\/wB\/Rc\/9If8A19xV36d\/7+i5\/wCkP\/r7irv07\/39Fz\/0h\/8AX3FXfp3\/AL+i5\/6Q\/wDr7irv07\/3&#xA;9Fz\/ANIf\/X3FXfp3\/v6Ln\/pD\/wCvuKu\/Tv8A39Fz\/wBIf\/X3FXfp3\/v6Ln\/pD\/6+4q79O\/8Af0XP&#xA;\/SH\/ANfcVZdoFlqScNQudWfUba5gDRRvEI6c+Dq\/227dvfFU8xV2KuxV2KpLrv8Ax1PLn\/bSk\/7p&#xA;2pYq7yZ\/yh+g\/wDbNs\/+TEeKp1irsVdirD\/NWo\/VNTWL9M\/o6sSt6P1X1q1LfFzoevhiqS\/pr\/v5&#xA;v+nD\/m3FXfpr\/v5v+nD\/AJtxV36a\/wC\/m\/6cP+bcVd+mv+\/m\/wCnD\/m3FU50\/Ttc1S1S9stfWSGQ&#xA;kKxtEX7JKnZqHqMVRP8Ah7zN\/wBXxf8ApFjxV3+HvM3\/AFfF\/wCkWPFXf4e8zf8AV8X\/AKRY8Vd\/&#xA;h7zN\/wBXxf8ApFjxV3+HvM3\/AFfF\/wCkWPFXf4e8zf8AV8X\/AKRY8Vd\/h7zN\/wBXxf8ApFjxV3+H&#xA;vM3\/AFfF\/wCkWPFXf4e8zf8AV8X\/AKRY8VT7Tre6tbKKC9n+tzpXnNxCcqsSvwrsKCgxVFYq7FXY&#xA;q7FUl13\/AI6nlz\/tpSf907UsVd5M\/wCUP0H\/ALZtn\/yYjxVOsVdirsVSPWNd\/Rt2Lf8ARdxe1QP6&#xA;sMfJdyRxrQ77YqgP8Wn\/AKsN7\/yJ\/wCbcVd\/i0\/9WG9\/5E\/824q7\/Fp\/6sN7\/wAif+bcVd\/i0\/8A&#xA;Vhvf+RP\/ADbiq4ecpVFF0O\/A8BER\/DFW\/wDGc3\/Vkv8A\/kWf6Yq7\/Gc3\/Vkv\/wDkWf6Yq7\/Gc3\/V&#xA;kv8A\/kWf6Yq7\/Gc3\/Vkv\/wDkWf6Yq7\/Gc3\/Vkv8A\/kWf6Yq7\/Gc3\/Vkv\/wDkWf6Yq7\/Gc3\/Vkv8A&#xA;\/kWf6Yq7\/Gc3\/Vkv\/wDkWf6Yq7\/Gc3\/Vkv8A\/kWf6Yqi9L8yS6leLaNpl3aBgx9WZCqCgr1p3xVP&#xA;cVdirsVdiqS67\/x1PLn\/AG0pP+6dqWKu8mf8ofoP\/bNs\/wDkxHiqdYq7FXYqw\/zV\/wAdNf8Ajr\/3&#xA;S\/8AHP8A7rq3X\/K8cVSX\/wAKPFXf+FHirv8Awo8Vd\/4UeKu\/8KPFXf8AhR4q7\/wo8Vd\/4UeKu\/8A&#xA;CjxV3\/hR4q7\/AMKPFXf+FHirv\/CjxV3\/AIUeKso8saZwVdU+s6g3qK0f1a\/bdfi+0U8fh2xVkWKu&#xA;xV2KuxVJdd\/46nlz\/tpSf907UsVd5M\/5Q\/Qf+2bZ\/wDJiPFU6xV2KuxVhfm6Tjqij1NUT9yu1iP3&#xA;XVuvxD4sVSP1f+L9e+7\/AJvxV3q\/8X6993\/N+Ku9X\/i\/Xvu\/5vxV3q\/8X6993\/N+Ku9X\/i\/Xvu\/5&#xA;vxV3q\/8AF+vfd\/zfirvV\/wCL9e+7\/m\/FXer\/AMX6993\/ADfirvV\/4v177v8Am\/FXer\/xfr33f834&#xA;q71f+L9e+7\/m\/FUx0bS31mSWNNQ1e19JQ1bg8Q1TT4fiOKpv\/gyb\/q93\/wDyMP8AXFXf4Mm\/6vd\/&#xA;\/wAjD\/XFU+02ybT7KKzaeS6MfL99Mau3Jmbc+1aYqisVdirsVdiqS67\/AMdTy5\/20pP+6dqWKu8m&#xA;f8ofoP8A2zbP\/kxHiqdYq7FXYqkur6rrNldCGw00XsRQMZTMkfxEmq8W+WKoH\/EPmb\/qxr\/0lR4q&#xA;7\/EPmb\/qxr\/0lR4q7\/EPmb\/qxr\/0lR4q7\/EPmb\/qxr\/0lR4q7\/EPmb\/qxr\/0lR4q7\/EPmb\/qxr\/0&#xA;lR4q7\/EPmb\/qxr\/0lR4q7\/EPmb\/qxr\/0lR4q7\/EPmb\/qxr\/0lR4q7\/EPmb\/qxr\/0lR4q7\/EPmb\/q&#xA;xr\/0lR4q7\/EPmb\/qxr\/0lR4q7\/EPmb\/qxr\/0lR4q7\/EPmb\/qxr\/0lR4q7\/EPmb\/qxr\/0lR4qyO2k&#xA;lltopZ4\/RldFaSKvLgxALLUdaHFVXFXYq7FUl13\/AI6nlz\/tpSf907UsVd5M\/wCUP0H\/ALZtn\/yY&#xA;jxVOsVdirsVYb5s0uS81NZV0eXUQIlX1knMYFC3w8aHpXFUk\/QM3\/Usz\/wDSUf8AmnFXfoGb\/qWZ&#xA;\/wDpKP8AzTirv0DN\/wBSzP8A9JR\/5pxV36Bm\/wCpZn\/6Sj\/zTirv0DN\/1LM\/\/SUf+acVd+gZv+pZ&#xA;n\/6Sj\/zTirv0DN\/1LM\/\/AElH\/mnFXfoGb\/qWZ\/8ApKP\/ADTirv0DN\/1LM\/8A0lH\/AJpxV36Bm\/6l&#xA;mf8A6Sj\/AM04q79Azf8AUsz\/APSUf+acVd+gZv8AqWZ\/+ko\/804q79Azf9SzP\/0lH\/mnFXfoGb\/q&#xA;WZ\/+ko\/804qydfIPl0qCYZQSNx6jbYqyVVCqFHQCg+jFW8VdirsVSXXf+Op5c\/7aUn\/dO1LFXeTP&#xA;+UP0H\/tm2f8AyYjxVOsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVS&#xA;XXf+Op5c\/wC2lJ\/3TtSxV3kz\/lD9B\/7Ztn\/yYjxVOsVdirsVSXV9K1u9uhNp+qtYwhApiEYarAmr&#xA;V5DxxVA\/4e80\/wDUwt\/yJH\/NWKu\/w95p\/wCphb\/kSP8AmrFXf4e80\/8AUwt\/yJH\/ADVirv8AD3mn&#xA;\/qYW\/wCRI\/5qxVE6do3mC1vIp7zWWu4EJ5wmMLyqCBvyPfFU\/wAVdirsVdirsVdirsVdirsVdirs&#xA;VdirsVdiqS67\/wAdTy5\/20pP+6dqWKu8mf8AKH6D\/wBs2z\/5MR4qnWKuxV2KqE17ZW7+ncXEUT0r&#xA;xd1U08aEjFVP9KaZ\/wAtkH\/I1P8AmrFXfpTTP+WyD\/kan\/NWKu\/Smmf8tkH\/ACNT\/mrFXfpTTP8A&#xA;lsg\/5Gp\/zVirv0ppn\/LZB\/yNT\/mrFUSjrIqujBlYAqwNQQehBxVdirsVdirsVdirsVdirsVdirsV&#xA;dirsVdiqS67\/AMdTy5\/20pP+6dqWKu8mf8ofoP8A2zbP\/kxHiqdYq7FXYqleo+W9F1a4F1qFt60w&#xA;UIG9SRfhBJAojqO+KoT\/AAP5X\/5Yf+Ss3\/VXFXf4H8r\/APLD\/wAlZv8Aqrirv8D+V\/8Alh\/5Kzf9&#xA;VcVd\/gfyv\/yw\/wDJWb\/qrirv8D+V\/wDlh\/5Kzf8AVXFU7t4IrWCO2gXhFCixxrUmiqOKipqegxVU&#xA;xV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxVJdd\/46nlz\/tpSf8AdO1LFXeTP+UP0H\/tm2f\/ACYjxVOs&#xA;VdirsVSTV\/NNlo10LS4trmZygk5QIrLQkilS677Yqgf8f6Z\/yxX\/APyKT\/qrirv8f6Z\/yxX\/APyK&#xA;T\/qrirv8f6Z\/yxX\/APyKT\/qrirv8f6Z\/yxX\/APyKT\/qrirv8f6Z\/yxX\/APyKT\/qriraefdMd1QWV&#xA;8CxABMSU3\/564qyjFXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FUl13\/AI6nlz\/tpSf907UsVd5M\/wCU&#xA;P0H\/ALZtn\/yYjxVOsVdirsVYh5pvPq+pKn6RvrT90p9O1i5p1b4q813xVJv0n\/2utW\/5Ef8AXzFU&#xA;XpmvwWN0J7m\/1K9TiV9GWD4anv8A3h6YqzLTNSg1W1F5bq6RsSoEq8WqvtviqLxV2KuxV2KuxV2K&#xA;uxV2KuxV2KuxV2KuxV2KuxV2KpLrv\/HU8uf9tKT\/ALp2pYq7yZ\/yh+g\/9s2z\/wCTEeKp1irsVdiq&#xA;Savouq6hdCey1eXT4wgUwohYEgn4q+onWuKoH\/C3mD\/qZJ\/+RR\/6r4q7\/C3mD\/qZJ\/8AkUf+q+Ku&#xA;\/wALeYP+pkn\/AORR\/wCq+Ku\/wt5g\/wCpkn\/5FH\/qvirI7WKSC1hgmlM8kUao8pFC7KAC5FT164qr&#xA;Yq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FUl13\/jqeXP+2lJ\/wB07UsVd5M\/5Q\/Qf+2bZ\/8AJiPF&#xA;U6xV2KuxVJdW8u6Zqt0Lm7mmjkCBOMcvAUBJ6U98VQX+C9C\/5arn\/kf\/AGYq7\/Behf8ALVc\/8j\/7&#xA;MVd\/gvQv+Wq5\/wCR\/wDZiqLsPKem6fdxXsEtw0kRJUSS8lNQV3FPfFU8xV2KuxV2KuxV2KuxV2Ku&#xA;xV2KuxV2KuxV2KuxVJdd\/wCOp5c\/7aUn\/dO1LFXeTP8AlD9B\/wC2bZ\/8mI8VTrFXYq7FWNeYJfJq&#xA;XwGvhTd+mpHJJWPCrcd4wR1riqV\/WPyy8I\/+Rdx\/zTirvrH5ZeEf\/Iu4\/wCacVd9Y\/LLwj\/5F3H\/&#xA;ADTiqcp518qxoqJe0VQFA9KbYD\/nnirf+OPK\/wDy3f8AJKb\/AKpYq7\/HHlf\/AJbv+SU3\/VLFXf44&#xA;8r\/8t3\/JKb\/qliqITzX5ddQ4v4gGFQGqp\/4FgDirf+KfLv8A1cIf+CxV3+KfLv8A1cIf+CxV3+Kf&#xA;Lv8A1cIf+CxV3+KfLv8A1cIf+CxV3+KfLv8A1cIf+CxVp\/NflxFLnUIiFFTxJY\/QFBJxVNgQwDDc&#xA;EVGKt4q7FXYq7FUl13\/jqeXP+2lJ\/wB07UsVd5M\/5Q\/Qf+2bZ\/8AJiPFU6xV2KuxVSkt7eVuUsSO&#xA;3SrKCafSMVW\/UrP\/AJZ4v+AX+mKu+pWf\/LPF\/wAAv9MVd9Ss\/wDlni\/4Bf6Yq76lZ\/8ALPF\/wC\/0&#xA;xV31Kz\/5Z4v+AX+mKu+pWf8Ayzxf8Av9MVd9Ss\/+WeL\/AIBf6Yq76lZ\/8s8X\/AL\/AExV31Kz\/wCW&#xA;eL\/gF\/pirvqVn\/yzxf8AAL\/TFXfUrP8A5Z4v+AX+mKu+pWf\/ACzxf8Av9MVd9Ss\/+WeL\/gF\/pirv&#xA;qVn\/AMs8X\/AL\/TFVbpireKuxV2KuxVJdd\/46nlz\/ALaUn\/dO1LFXeTP+UP0H\/tm2f\/JiPFU6xV2K&#xA;uxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxVJdd\/wCOp5c\/7aUn\/dO1LFXe&#xA;TP8AlD9B\/wC2bZ\/8mI8VTrFXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq&#xA;7FUl13\/jqeXP+2lJ\/wB07UsVd5M\/5Q\/Qf+2bZ\/8AJiPFU6xV2KuxV2KuxV2KuxV2KuxV2KuxV2Ku&#xA;xV2KuxV2KuxV2KuxV2KuxV2KuxVJdd\/46nlz\/tpSf907UsVd5M\/5Q\/Qf+2bZ\/wDJiPFU6xV2KuxV&#xA;2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxVJdd\/46nlz\/ALaUn\/dO1LFXeTP+&#xA;UP0H\/tm2f\/JiPFU6xV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxVJdd&#xA;\/wCOp5c\/7aUn\/dO1LFXeTP8AlD9B\/wC2bZ\/8mI8VTrFXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq&#xA;7FXYq7FXYq7FXYq7FXYq7FUl13\/jqeXP+2lJ\/wB07UsVSnyn5s8q23lXRbe41rT4ZodPtY5I5LqF&#xA;XR1hjVlZWkBBBG4xVNv8Z+T\/APq\/ab\/0mQf9VMVd\/jPyf\/1ftN\/6TIP+qmKu\/wAZ+T\/+r9pv\/SZB&#xA;\/wBVMVd\/jPyf\/wBX7Tf+kyD\/AKqYq7\/Gfk\/\/AKv2m\/8ASZB\/1UxV3+M\/J\/8A1ftN\/wCkyD\/qpirv&#xA;8Z+T\/wDq\/ab\/ANJkH\/VTFXf4z8n\/APV+03\/pMg\/6qYq7\/Gfk\/wD6v2m\/9JkH\/VTFXf4z8n\/9X7Tf&#xA;+kyD\/qpirv8AGfk\/\/q\/ab\/0mQf8AVTFXf4z8n\/8AV+03\/pMg\/wCqmKu\/xn5P\/wCr9pv\/AEmQf9VM&#xA;Vd\/jPyf\/ANX7Tf8ApMg\/6qYq7\/Gfk\/8A6v2m\/wDSZB\/1UxV3+M\/J\/wD1ftN\/6TIP+qmKu\/xn5P8A&#xA;+r9pv\/SZB\/1UxV3+M\/J\/\/V+03\/pMg\/6qYq7\/ABn5P\/6v2m\/9JkH\/AFUxV3+M\/J\/\/AFftN\/6TIP8A&#xA;qpirv8Z+T\/8Aq\/ab\/wBJkH\/VTFXf4z8n\/wDV+03\/AKTIP+qmKu\/xn5P\/AOr9pv8A0mQf9VMVSnWf&#xA;NnlWXUdAeLWtPdINQkklZbqEhENhfx8nIk2HJ1FT3IxV\/9k=<\/xmpGImg:image>\n               <\/rdf:li>\n            <\/rdf:Seq>\n         <\/xmp:PageInfo>\n      <\/rdf:Description>\n      <rdf:Description rdf:about=\"\"\n            xmlns:idPriv=\"http:\/\/ns.adobe.com\/xmp\/InDesign\/private\">\n         <idPriv:DocChangeCount>191<\/idPriv:DocChangeCount>\n      <\/rdf:Description>\n      <rdf:Description rdf:about=\"\"\n            xmlns:dc=\"http:\/\/purl.org\/dc\/elements\/1.1\/\">\n         <dc:format>application\/pdf<\/dc:format>\n      <\/rdf:Description>\n      <rdf:Description rdf:about=\"\"\n            xmlns:pdf=\"http:\/\/ns.adobe.com\/pdf\/1.3\/\">\n         <pdf:Producer>Adobe PDF Library 9.9<\/pdf:Producer>\n         <pdf:Trapped>False<\/pdf:Trapped>\n      <\/rdf:Description>\n   <\/rdf:RDF>\n<\/x:xmpmeta>\n                                                                                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n                           \n<?xpacket end=\"w\"?> "}}],"SUBDIRECTORIES":[]},"SUMMARY":{"FILES":{"BY TYPE":{"jpeg":0,"pdf":1},"CRAWLED":1},"TIME":{"ENDED":"2015-11-10 09:31:20","STARTED":"2015-11-10 09:31:19"}},"TARGET DIRECTORY":"D:\\Work\\dataextractor\\work\\pdf"}